
The PDP-8 is a 12-bit minicomputer that was produced by Digital Equipment Corporation (DEC). It was the first commercially successful minicomputer, with over 50,000 units being sold over the model's lifetime. Its basic design follows the pioneering LINC but has a smaller instruction set, which is an expanded version of the PDP-5 instruction set. Similar machines from DEC are the PDP-12 which is a modernized version of the PDP-8 and LINC concepts, and the PDP-14 industrial controller system.
Overview.
The earliest PDP-8 model, informally known as a "Straight-8", was introduced on 22 March 1965 priced at $18,500 (). It used diode–transistor logic packaged on flip chip cards in a machine about the size of a small household refrigerator. It was the first computer to be sold for under $20,000, making it the best-selling computer in history at that time. The Straight-8 was supplanted in 1966 by the PDP-8/S, which was available in desktop and rack-mount models. Using a one-bit serial arithmetic logic unit (ALU) allowed the PDP-8/S to be smaller and less expensive, although slower than the original PDP-8. A basic 8/S sold for under $10,000, the first machine to reach that milestone.
Later systems (the PDP-8/I and /L, the PDP-8/E, /F, and /M, and the PDP-8/A) returned to a faster, fully parallel implementation but use much less costly transistor–transistor logic (TTL) MSI logic. Most surviving PDP-8s are from this era. The PDP-8/E is common, and well-regarded because many types of I/O devices were available for it. The last commercial PDP-8 models introduced in 1979 are called "CMOS-8s", based on CMOS microprocessors. They were not priced competitively, and the offering failed. Intersil sold the integrated circuits commercially through 1982 as the Intersil 6100 family. By virtue of their CMOS technology they had low power requirements and were used in some embedded military systems.
The chief engineer who designed the initial version of the PDP-8 was Edson de Castro, who later founded Data General.
Architectural significance.
The PDP-8 combines low cost, simplicity, expandability, and careful engineering for value. The greatest historical significance was that the PDP-8's low cost and high volume made a computer available to many new customers for many new uses. Its continuing significance is as a historical example of value-engineered computer design.
The low complexity brought other costs. It made programming cumbersome, as is seen in the examples in this article and from the discussion of "pages" and "fields". Much of one's code performed the required mechanics, as opposed to setting out the algorithm. For example, subtracting a number involves computing its two's complement then adding it; writing a conditional jump involves writing a conditional skip around the jump, the skip coding the condition negative to the one desired. Some ambitious programming projects failed to fit in memory or developed design defects that could not be solved. For example, as noted below, inadvertent recursion of a subroutine produces defects that are difficult to trace to the subroutine in question.
As design advances reduced the costs of logic and memory, the programmer's time became relatively more important. Subsequent computer designs emphasized ease of programming, typically using larger and more intuitive instruction sets.
Eventually, most machine code was generated by compilers and report generators. The reduced instruction set computer returned full-circle to the PDP-8's emphasis on a simple instruction set and achieving multiple actions in a single instruction cycle, in order to maximize execution speed, although the newer computers have much longer instruction words.
Description.
The PDP-8 used ideas from several 12-bit predecessors, most notably the LINC designed by W.A. Clark and C.E. Molnar, who were inspired by Seymour Cray's CDC 160 minicomputer.
The PDP-8 uses 12 bits for its word size and arithmetic (on unsigned integers from 0 to 4095 or signed integers from −2048 to +2047). However, software can do multiple-precision arithmetic. An interpreter was available for floating point operations, for example, that used a 36-bit floating point representation with a two-word (24-bit) significand and one-word exponent. Subject to speed and memory limitations, the PDP-8 can perform calculations similar to more expensive contemporary electronic computers, such as the IBM 1130 and various models of the IBM System/360, while being easier to interface with external devices.
The memory address space is also 12 bits, so the PDP-8's basic configuration has a main memory of 4,096 (212) twelve-bit words. An optional memory-expansion unit can switch banks of memories using an IOT instruction. The memory is magnetic-core memory with a cycle time of 1.5 microseconds (0.667 MHz), so that a typical two-cycle (Fetch, Execute) memory-reference instruction runs at a speed of 0.333 MIPS. The 1974 Pocket Reference Card for the PDP-8/E gives a basic instruction time of 1.2 microseconds, or 2.6 microseconds for instructions that reference memory.
The PDP-8 was designed in part to handle contemporary telecommunications and text. Six-bit character codes were in widespread use at the time, and the PDP-8's twelve-bit words can efficiently store two such characters. In addition, a six-bit teleprinter code called the teletypesetting or TTS code was in widespread use by the news wire services, and an early application for the PDP-8 was typesetting using this code.
PDP-8 instructions have a 3-bit opcode, so there are only eight instructions. The assembler provides more instruction mnemonics to a programmer by translating I/O and operate-mode instructions to combinations of the op-codes and instruction fields. It also has only three programmer-visible registers: A 12-bit accumulator (AC), a program counter (PC), and a carry flag called the "link register" (L).
For input and output, the PDP-8 has a single interrupt shared by all devices, an I/O bus accessed by I/O instructions and a direct memory access (DMA) channel. The programmed I/O bus typically runs low to medium-speed peripherals, such as printers, teletypes, paper tape punches and readers, while DMA is used for cathode ray tube screens with a light pen, analog-to-digital converters, digital-to-analog converters, tape drives, and disk drives.
To save money, the design used inexpensive main memory for many purposes that are served by more expensive flip-flop registers in other computers, such as auxiliary counters and subroutine linkage.
Basic models use software to do multiplication and division. For faster math, the Extended Arithmetic Element (EAE) provides multiply and divide instructions with an additional register, the Multiplier/Quotient (MQ) register. The EAE was an option on the original PDP-8, the 8/I, and the 8/E, but it is an integral part of the Intersil 6100 microprocessor.
The PDP-8 is optimized for simplicity of design. Compared to more complex machines, unnecessary features were removed and logic is shared when possible. Instructions use autoincrement, autoclear, and indirect access to increase the software's speed, reduce memory use, and substitute inexpensive memory for expensive registers.
The electronics of a basic PDP-8 CPU has only four 12-bit registers: the accumulator, program counter, memory-buffer register, and memory-address register. To save money, these served multiple purposes at different points in the operating cycle. For example, the memory buffer register provides arithmetic operands, is part of the instruction register, and stores data to rewrite the core memory. (This restores the core data destroyed by the read.)
Because of their simplicity, early PDP-8 models were less expensive than most other commercially available computers. However, they used costly production methods often used for prototypes. They used thousands of very small, standardized logic-modules, with gold connectors, integrated by a costly, complex wire-wrapped backplane in a large cabinet.
In the later 8/S model, introduced in August 1966, two different logic voltages increased the fan-out of the inexpensive diode–transistor logic. The 8/S also reduced the number of logic gates by using a serial, single-bit-wide data path to do arithmetic. The CPU of the PDP-8/S has only about 519 logic gates. In comparison, small microcontrollers (as of 2008) usually have 15,000 or more. The reductions in the electronics permitted a much smaller case, about the size of a bread-box. The 8/S was designed by Saul Dinman.
The even later PDP-8/E is a larger, more capable computer, but further reengineered for better value. It employs faster transistor–transistor logic, in integrated circuits. The core memory was redesigned. It allows expansion with less expense because it uses the OMNIBUS in place of the wire-wrapped backplane on earlier models. (A personal account of the development of the PDP-8/E can be read on the Engineering and Technology History Wiki.)
Versions of the PDP-8.
The total sales figure for the PDP-8 family has been estimated at over 300,000 machines. The following models were manufactured:
Latter-day implementations.
The PDP-8 is readily emulated, as its instruction set is much simpler than modern architectures. Enthusiasts have created entire PDP-8s using single FPGA devices.
Several software simulations of a PDP-8 are available on the Internet, as well as open-source hardware re-implementations. The best of these correctly execute DEC's operating systems and diagnostic software. The software simulations often simulate late-model PDP-8s with all possible peripherals. Even these use only a tiny fraction of the capacity of a modern personal computer.
One of the first commercial versions of a PDP-8/S virtual machine ran on a Kaypro 386 (an 80386-based computer) and was written in the C computer language (before the ANSI-C standard was finalized) and assembler by David Beecher of Denver, Colorado. It replaced a failing PDP-8/S computer that operated the fuel handling machine at Reactor #85, the Platteville, Colorado Nuclear Fuel powered Electric Generating Station, Ft. St. Vrain. It was reviewed by Rockwell International and performed flawlessly for 2.5 years during the operation of the Fuel Handling Machine while it was used to remove fuel from the reactor core and decommission the plant. It included a simulated paper tape loader and front panel.
Input/output.
The I/O systems underwent huge changes during the PDP-8 era. Early PDP-8 models use a front panel interface, a paper-tape reader and a teletype printer with an optional paper-tape punch. Over time, I/O systems such as magnetic tape, RS-232 and current loop dumb terminals, punched card readers, and fixed-head disks were added. Toward the end of the PDP-8 era, floppy disks and moving-head cartridge disk drives were popular I/O devices. Modern enthusiasts have created standard PC style IDE hard disk adapters for real and simulated PDP-8 computers.
Several types of I/O are supported:
A simplified, inexpensive form of DMA called "three-cycle data break" is supported; this requires the assistance of the processor. The "data break" method moves some of common logic needed to implement DMA I/O from each I/O device into one common copy of the logic within the processor. "Data break" places the processor in charge of maintaining the DMA address and word count registers. In three successive memory cycles, the processor updates the word count, updates the transfer address, and stores or retrieves the actual I/O data word.
One-cycle data break effectively triples the DMA transfer rate because only the target data needed to be transferred to and from the core memory. However, the I/O devices need more electronic logic to manage their own word count and transfer address registers. By the time the PDP-8/E was introduced, electronic logic had become less expensive and "one-cycle data break" became more popular.
Programming facilities.
Early PDP-8 systems did not have an operating system, just a front panel with run and halt switches. Software development systems for the PDP-8 series began with the most basic front-panel entry of raw binary machine code (booting entry).
In the middle era, various paper tape "operating systems" were developed. Many utility programs became available on paper tape. PAL-8 assembly language source code was often stored on paper tape, read into memory, and saved to paper tape. PAL assembled from paper tape into memory. Paper tape versions of a number of programming languages were available, including DEC's FOCAL interpreter and a 4K FORTRAN compiler and runtime.
Toward the end of the PDP-8 era, operating systems such as OS/8 and COS-310 allowed a traditional line mode editor and command-line compiler development system using languages such as PAL-III assembly language, FORTRAN, BASIC, and DIBOL.
Fairly modern and advanced real-time operating system (RTOS) and preemptive multitasking multi-user systems were available: a real-time system (RTS-8) was available as were multiuser commercial systems (COS-300 and COS-310) and a dedicated single-user word-processing system (WPS-8).
A time-sharing system, TSS-8, was also available. TSS-8 allows multiple users to log into the system via 110-baud terminals, and edit, compile and debug programs. Languages include a special version of BASIC, a FORTRAN subset similar to FORTRAN-1 (no user-written subroutines or functions), an ALGOL subset, FOCAL, and an assembler called PAL-D.
A fair amount of user-donated software for the PDP-8 was available from DECUS, the Digital Equipment Corporation User Society, and often came with full source listings and documentation.
Instruction set.
The three high-order bits of the 12-bit instruction word (labelled bits 0 through 2) are the operation code. For the six operations that refer to memory, bits 5 through 11 provide a 7-bit address. Bit 4, if set, says to complete the address using the 5 high-order bits of the program counter (PC) register, meaning that the addressed location was within the same 128 words as the instruction. If bit 4 is clear, zeroes are used, so the addressed location is within the first 128 words of memory. Bit 3 specifies indirection; if set, the address obtained as described so far points to a 12-bit value in memory that gives the actual effective address for the instruction; this allows operands to be anywhere in memory at the expense of an additional word. The JMP instruction does not operate on a memory word, except if indirection is specified, but has the same bit fields.
This use of the instruction word divides the 4,096-word memory into 128-word pages; bit 4 of the instruction selects either the current page or page 0 (addresses 0000–0177 in octal). Memory in page 0 is at a premium, since variables placed here can be addressed directly from any page. (Moreover, address 0000 is where any interrupt service routine must start, and addresses 0010–0017 have the special property of auto-incrementing preceding any indirect reference through them.)
The standard assembler places constant values for arithmetic in the current page. Likewise, cross-page jumps and subroutine calls use an indirect address in the current page.
It was important to write routines to fit within 128-word pages, or to arrange routines to minimize page transitions, as references and jumps outside the current page require an extra word. Consequently, much time was spent cleverly conserving one or several words. Programmers deliberately placed code at the end of a page to achieve a free transition to the next page as PC was incremented.
IOT (Input-Output Transfer) instructions.
The PDP-8 processor defined few of the IOT instructions, but simply provided a framework. Most IOT instructions were defined by the individual I/O devices.
Bits 3 through 8 of an IOT instruction select an I/O device. Some of these device addresses are standardized by convention:
Instructions for device 0 affect the processor as a whole. For example, ION (6001) enables interrupt processing, and IOFF (6002) disables it.
Bits 9 through 11 of an IOT instruction select the function(s) the device performs. Simple devices (such as the paper tape reader and punch and the console keyboard and printer) use the bits in standard ways:
These operations take place in a well-defined order that gives useful results if more than one bit is set.
More complicated devices, such as disk drives, use these 3 bits in device-specific fashions. Typically, a device decodes the 3 bits to give 8 possible function codes.
OPR (OPeRate).
Many operations are achieved using OPR, including most of the conditionals. OPR does not address a memory location; conditional execution is achieved by conditionally skipping one instruction, which is typically a JMP.
The OPR instruction was said to be "microcoded." This did not mean what the word means today (that a lower-level program fetched and interpreted the OPR instruction), but meant that each bit of the instruction word specifies a certain action, and the programmer could achieve several actions in a single instruction cycle by setting multiple bits. In use, a programmer can write several instruction mnemonics alongside one another, and the assembler combines them with OR to devise the actual instruction word. Many I/O devices support "microcoded" IOT instructions.
Microcoded actions take place in a well-defined sequence designed to maximize the utility of many combinations.
The OPR instructions come in Groups. Bits 3, 8 and 11 identify the Group of an OPR instruction, so it is impossible to combine the microcoded actions from different groups.
Group 1.
In most cases, the operations are sequenced so that they can be combined in the most useful ways. For example, combining CLA (CLear Accumulator), CLL (CLear Link), and IAC (Increment ACcumulator) first clears the AC and Link, then increments the accumulator, leaving it set to 1. Adding RAL to the mix (so CLA CLL IAC RAL) causes the accumulator to be cleared, incremented, then rotated left, leaving it set to 2. In this way, small integer constants were placed in the accumulator with a single instruction.
The combination CMA IAC, which the assembler lets you abbreviate as CIA, produces the arithmetic inverse of AC: the twos-complement negation. Since there is no subtraction instruction, only the twos-complement add (TAD), computing the difference of two operands, requires first negating the subtrahend.
A Group 1 OPR instruction that has none of the microprogrammed bits set performs no action. The programmer can write NOP (No Operation) to assemble such an instruction.
Group 2, Or Group.
When bit 8 is clear, a skip is performed if any of the specified conditions are true. For example, "SMA SZA", opcode 7540, skips if AC ≤ 0.
A Group 2 OPR instruction that has none of the microprogrammed bits set is another No-Op instruction.
Group 2, And Group.
When bit 8 is set, the Group 2, Or skip condition is inverted, via De Morgan's laws: the skip is "not" performed if any of the group 2, Or conditions are true, meaning that "all" of the specified skip conditions must be true. For example, "SPA SNA", opcode 7550, skips if AC &gt; 0. If none of bits 5–7 are set, then the skip is unconditional.
Group 3.
Unused bit combinations of OPR are defined as a third Group of microprogrammed actions mostly affecting the MQ (Multiplier/Quotient) register. The MQ register and the extended arithmetic element (EAE) instructions are optional and only exist when EAE option was purchased.
Typically CLA and MQA were combined to transfer MQ into AC. Another useful combination is MQA and MQL, to exchange the two registers.
Three bits specified a multiply/divide instruction to perform:
Memory control.
A 12-bit word can have 4,096 different values, and this is the maximum number of words the original PDP-8 can address indirectly through a word pointer. 4,096 12-bit words represent 6,144 bytes in modern terminology, or 6 kB. As programs became more complex and the price of memory fell, it became desirable to expand this limit.
To maintain compatibility with pre-existing programs, new hardware outside the original design added high-order bits to the effective addresses generated by the program. The Memory Extension Controller expands the addressable memory by a factor of 8, to a total of 32,768 words. This expansion was thought sufficient because, with core memory then costing about 50 cents a word, a full 32K of memory would equal the cost of the CPU.
Each 4K of memory is called a field. The Memory Extension Controller contains two three-bit registers: the DF (Data Field) and the IF (Instruction Field). These registers specify a field for each memory reference of the CPU, allowing a total of 15 bits of address. The IF register specifies the field for instruction fetches and direct memory references; the DF register specifies the field for indirect data accesses. A program running in one field can reference data in the same field by direct addressing, and reference data in another field by indirect addressing.
A set of I/O instructions in the range 6200 through 6277 is handled by the Memory Extension Controller and give access to the DF and IF registers. The 62X1 instruction (CDF, Change Data Field) set the data field to X. Similarly 62X2 (CIF) set the instruction field, and 62X3 set both. Pre-existing programs would never execute CIF or CDF; the DF and IF registers would both point to the same field, a single field to which these programs were limited. The effect of the CIF instruction was deferred to coincide with the next JMP or JMS instruction, so that executing CIF would not cause a jump.
It was more complicated for multiple-field programs to deal with field boundaries and the DF and IF registers than it would have been if they could simply generate 15-bit addresses, but the design provided backward compatibility and is consistent with the 12-bit architecture used throughout the PDP-8. Compare the later Intel 8086, whose 16-bit memory addresses are expanded to 20 bits by combining them with the contents of a specified or implied segment register.
The extended memory scheme let existing programs handle increased memory with minimal changes. For example, 4K FOCAL normally had about 3K of code with only 1K left over for user program and data. With a few patches, FOCAL could use a second 4K field for user program and data. Moreover, additional 4K fields could be allocated to separate users, turning 4K FOCAL into a multi-user timesharing system.
On the PDP-8/E and later models, the Memory Extension Controller was enhanced to enable machine virtualization. A program written to use a PDP-8's entire resources can coexist with other such programs on the same PDP-8 under the control of a virtual machine manager. The manager can make all I/O instructions (including those that operated on the Memory Extension Controller) cause a trap (an interrupt handled by the manager). In this way, the manager can map memory references, map data or instruction fields, and redirect I/O to different devices. Each original program has complete access to a "virtual machine" provided by the manager.
New I/O instructions to the Memory Extension Controller retrieve the current value of the data and instruction fields, letting software save and restore most of the machine state across a trap. However, a program can not sense whether the CPU is in the process of deferring the effect of a CIF instruction (whether it has executed a CIF and not yet executed the matching jump instruction). The manager has to include a complete PDP-8 emulator (not difficult for an 8-instruction machine). Whenever a CIF instruction traps to the manager, it has to emulate the instructions up to the next jump. Fortunately, as a jump usually is the next instruction after CIF, this emulation does not slow programs down much, but it is a large workaround to a seemingly small design deficiency.
By the time of the PDP-8/A, memory prices had fallen enough that memory exceeding 32K was desirable. The 8/A added a new set of instructions for handling more than eight fields of memory. The field number could now be placed in the AC, rather than hard-coded into the instruction. However, by this time, the PDP-8 was in decline, so very little standard software was modified to use these new features.
Examples.
The following examples show code in PDP-8 assembly language as one might write for the PAL-III assembler.
Comparing two numbers.
The following piece of code shows what is needed just to compare two numbers:
As shown, much of the text of a typical PDP-8 program focuses not on the author's intended algorithm but on low-level mechanics. An additional readability problem is that in conditional jumps such as the one shown above, the conditional instruction (which skips around the JMP) highlights the opposite of the condition of interest.
String output.
This complete PDP-8 assembly language program outputs "Hello, world!" to the teleprinter.
Subroutines.
The PDP-8 processor does not implement a stack upon which to store registers or other context when a subroutine is called or an interrupt occurs. (A stack can be implemented in software, as demonstrated in the next section.) Instead, the JMS instruction simply stores the updated PC (pointing past JMS, to the return address) at the effective address and jumps to the effective address plus one. The subroutine returned to its caller using an indirect JMP instruction that addresses the subroutine's first word.
For example, here is "Hello, World!" re-written to use a subroutine. When the JMS instruction jumps to the subroutine, it modifies the 0 coded at location OUT1:
The fact that the JMS instruction uses the word just before the code of the subroutine to deposit the return address prevents reentrancy and recursion without additional work by the programmer. It also makes it difficult to use ROM with the PDP-8 because read-write return-address storage is commingled with read-only code storage in the address space. Programs intended to be placed into ROMs approach this problem in several ways:
The use of the JMS instruction makes debugging difficult. If a programmer makes the mistake of having a subroutine call itself, directly or by an intermediate subroutine, then the return address for the outer call is destroyed by the return address of the subsequent call, leading to an infinite loop. If one module is coded with an incorrect or obsolete address for a subroutine, it would not just fail to execute the entire code sequence of the subroutine, it might modify a word of the subroutine's code, depositing a return address that the processor might interpret as an instruction during a subsequent correct call to the subroutine. Both types of error might become evident during the execution of code that was written correctly.
Software stack.
Though the PDP-8 does not have a hardware stack, stacks can be implemented in software.
Here are example PUSH and POP subroutines, simplified to omit issues such as testing for stack overflow and underflow:
And here is "Hello World" with this "stack" implemented, and "OUT" subroutine:
Linked list.
Another possible subroutine for the PDP-8 is a linked list.
Interrupts.
There is a single interrupt line on the PDP-8 I/O bus. The processor handles any interrupt by disabling further interrupts and executing a codice_1 to location 0000. As it is difficult to write reentrant subroutines, it is difficult to nest interrupts and this is usually not done; each interrupt runs to completion and re-enables interrupts just before executing the codice_2 instruction that returns from the interrupt.
Because there is only a single interrupt line on the I/O bus, the occurrence of an interrupt does not inform the processor of the source of the interrupt. Instead, the interrupt service routine has to serially poll each active I/O device to see if it is the source. The code that does this is called a "skip chain" because it consists of a series of PDP-8 "test and skip if flag set" I/O instructions. (It was not unheard-of for a skip chain to reach its end without finding any device in need of service.) The relative interrupt priority of the I/O devices is determined by their position in the skip chain: If several devices interrupt, the device tested earlier in the skip chain is serviced first.
Books.
An engineering textbook popular in the 1980s, "The Art of Digital Design" by David Winkel and Franklin Prosser, contains an example problem spanning several chapters in which the authors demonstrate the process of designing a computer that is compatible with the PDP-8/I. The function of every component is explained. Although it is not a production design, as it uses more modern SSI and MSI components, the exercise provides a detailed description of the computer's operation.
Unlicensed clones.
The USSR produced minicomputers Saratov-1 and Saratov-2, respectively, PDP-8 and PDP-8/E.

