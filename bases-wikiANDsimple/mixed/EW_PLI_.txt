
PL/I (Programming Language One, pronounced and sometimes written PL/1) is a procedural, imperative computer programming language developed and published by IBM. It is designed for scientific, engineering, business and system programming. It has been used by academic, commercial and industrial organizations since it was introduced in the 1960s, and is still used.
PL/I's main domains are data processing, numerical computation, scientific computing, and system programming. It supports recursion, structured programming, linked data structure handling, fixed-point, floating-point, complex, character string handling, and bit string handling. The language syntax is English-like and suited for describing complex data formats with a wide set of functions available to verify and manipulate them.
Early history.
In the 1950s and early 1960s, business and scientific users programmed for different computer hardware using different programming languages. Business users were moving from Autocoders via COMTRAN to COBOL, while scientific users programmed in General Interpretive Programme (GIP), Fortran, ALGOL, GEORGE, and others. The IBM System/360 (announced in 1964 and delivered in 1966) was designed as a common machine architecture for both groups of users, superseding all existing IBM architectures. Similarly, IBM wanted a single programming language for all users. It hoped that Fortran could be extended to include the features needed by commercial programmers. In October 1963 a committee was formed composed originally of three IBMers from New York and three members of SHARE, the IBM
scientific users group, to propose these extensions to Fortran. Given the constraints of Fortran, they were unable to do this and embarked on the design of a new programming language based loosely on ALGOL labeled NPL. This acronym conflicted with that of the UK's National Physical Laboratory and was replaced briefly by MPPL (MultiPurpose Programming Language) and, in 1965, with PL/I (with a Roman numeral "I"). The first definition appeared in April 1964.
IBM took NPL as a starting point and completed the design to a level that the first compiler could be written: the NPL definition was incomplete in scope and in detail. Control of the PL/I language was vested initially in the New York Programming Center and later at the IBM UK Laboratory at Hursley. The SHARE and GUIDE user groups were involved in extending the language and had a role in IBM's process for controlling the language through their PL/I Projects. The experience of defining such a large language showed the need for a formal definition of PL/I. A project was set up in 1967 in IBM Laboratory Vienna to make an unambiguous and complete specification. This led in turn to one of the first large scale Formal Methods for development, VDM.
Fred Brooks is credited with ensuring PL/I had the CHARACTER data type.
The language was first specified in detail in the manual "PL/I Language Specifications. C28-6571" written in New York from 1965 and superseded by "PL/I Language Specifications. GY33-6003" written in Hursley from 1967. IBM continued to develop PL/I in the late sixties and early seventies, publishing it in the GY33-6003 manual. These manuals were used by the Multics group and other early implementers.
The first compiler was delivered in 1966. The Standard for PL/I was approved in 1976.
Goals and principles.
The goals for PL/I evolved during the early development of the language. Competitiveness with COBOL's record handling and report writing was required. The language's scope of usefulness grew to include system programming and event-driven programming. Additional goals for PL/I were:
To achieve these goals, PL/I borrowed ideas from contemporary languages while adding substantial new capabilities and casting it with a distinctive concise and readable syntax. Many principles and capabilities combined to give the language its character and were important in meeting the language's goals:
Language summary.
The language is designed to be all things to all programmers. The summary is extracted from the ANSI PL/I Standard
and the ANSI PL/I General-Purpose Subset Standard.
A PL/I program consists of a set of procedures, each of which is written as a sequence of statements. The codice_5 construct is used to include text from other sources during program translation. All of the statement types are summarized here in groupings which give an overview of the language (the Standard uses this organization).
Names may be declared to represent data of the following types, either as single values, or as aggregates in the form of arrays, with a lower-bound and upper-bound per dimension, or structures (comprising nested structure, array and scalar variables):
The codice_6 type comprises these attributes:
The base, scale, precision and scale factor of the codice_7 type is encoded within the codice_8. The mode is specified separately, with the codice_9 applied to both the real and the imaginary parts.
Values are computed by expressions written using a specific set of operations and builtin functions, most of which may be applied to aggregates as well as to single values, together with user-defined procedures which, likewise, may operate on and return aggregate as well as single values. The assignment statement assigns values to one or more variables.
There are no reserved words in PL/I. A statement is terminated by a semi-colon. The maximum length of a statement is implementation defined. A comment may appear anywhere in a program where a space is permitted and is preceded by the characters forward slash, asterisk and is terminated by the characters asterisk, forward slash (i.e. ). Statements may have a label-prefix introducing an entry name (codice_10 and codice_11 statements) or label name, and a condition prefix enabling or disabling a computational condition e.g. codice_12). Entry and label names may be single identifiers or identifiers followed by a subscript list of constants (as in codice_13).
A sequence of statements becomes a "group" when preceded by a codice_4 statement and followed by an codice_15 statement. Groups may include nested groups and begin blocks. The codice_16 statement specifies a group or a single statement as the codice_17 part and the codice_18 part (see the sample program). The group is the unit of iteration. The begin "block" (codice_19) may contain declarations for names and internal procedures local to the block. A "procedure" starts with a codice_11 statement and is terminated syntactically by an codice_15 statement. The body of a procedure is a sequence of blocks, groups, and statements and contains declarations for names and procedures local to the procedure or codice_22 to the procedure.
An "ON-unit" is a single statement or block of statements written to be executed when one or more of these "conditions" occur:
a "computational condition",
or an "Input/Output" condition,
or one of the conditions:
A declaration of an identifier may contain one or more of the following attributes (but they need to be mutually consistent):
Current compilers from Micro Focus, and particularly that from IBM implement many extensions over the standardized version of the language. The IBM extensions are summarised in the Implementation sub-section for the compiler later. Although there are some extensions common to these compilers the lack of a current standard means that compatibility is not guaranteed.
Standardization.
Language standardization began in April 1966 in Europe with ECMA TC10. In 1969 ANSI established a "Composite Language Development Committee", nicknamed "Kludge", later renamed X3J1 PL/I. Standardization became a joint effort of ECMA TC/10 and ANSI X3J1. A subset of the GY33-6003 document was offered to the joint effort by IBM and became the base document for standardization. The major features omitted from the base document were multitasking and the attributes for program optimization (e.g. codice_27 and codice_28).
Proposals to change the base document were voted upon by both committees. In the event that the committees disagreed, the chairs, initially Michael Marcotty of General Motors and C.A.R. Hoare representing ICL had to resolve the disagreement. In addition to IBM, Honeywell, CDC, Data General, Digital Equipment Corporation, Prime Computer, Burroughs, RCA, and Univac served on X3J1 along with major users Eastman Kodak, MITRE, Union Carbide, Bell Laboratories, and various government and university representatives. Further development of the language occurred in the standards bodies, with continuing improvements in structured programming and internal consistency, and with the omission of the more obscure or contentious features.
As language development neared an end, X3J1/TC10 realized that there were a number of problems with a document written in English text. Discussion of a single item might appear in multiple places which might or might not agree. It was difficult to determine if there were omissions as well as inconsistencies. Consequently, David Beech (IBM), Robert Freiburghouse (Honeywell), Milton Barber (CDC), M. Donald MacLaren (Argonne National Laboratory), Craig Franklin (Data General), Lois Frampton (Digital Equipment Corporation), and editor, D.J. Andrews of IBM undertook to rewrite the entire document, each producing one or more complete chapters. The standard is couched as a formal definition using a "PL/I Machine" to specify the semantics. It was the first, and possibly the only, programming language standard to be written as a semi-formal definition.
A "PL/I General-Purpose Subset" ("Subset-G") standard was issued by ANSI in 1981 and a revision published in 1987. The General Purpose subset was widely adopted as the kernel for PL/I implementations.
Implementations.
IBM PL/I F and D compilers.
PL/I was first implemented by IBM, at its Hursley Laboratories in the United Kingdom, as part of the development of System/360. The first production PL/I compiler was the PL/I F compiler for the OS/360 Operating System, built by John Nash's team at Hursley in the UK: the runtime library team was managed by I.M. (Nobby) Clarke. The PL/I F compiler was written entirely in System/360 assembly language. Release 1 shipped in 1966. OS/360 is a real-memory environment and the compiler was designed for systems with as little as 64 kilobytes of real storage – F being 64 kB in S/360 parlance. To fit a large compiler into the 44 kilobytes of memory available on a 64-kilobyte machine, the compiler consists of a control phase and a large number of compiler phases (approaching 100). The phases are brought into memory from disk, one at a time, to handle particular language features and aspects of compilation. Each phase makes a single pass over the partially-compiled program, usually held in memory.
Aspects of the language were still being designed as PL/I F was implemented, so some were omitted until later releases. PL/I RECORD I/O was shipped with PL/I F Release 2. The list processing functions Based Variables, Pointers, Areas and Offsets and LOCATE-mode I/O were first shipped in Release 4. In a major attempt to speed up PL/I code to compete with Fortran object code, PL/I F Release 5 does substantial program optimization of DO-loops facilitated by the REORDER option on procedures.
A version of PL/I F was released on the TSS/360 timesharing operating system for the System/360 Model 67, adapted at the IBM Mohansic Lab. The IBM La Gaude Lab in France developed "Language Conversion Programs" to convert Fortran, Cobol, and Algol programs to the PL/I F level of PL/I.
The PL/I D compiler, using 16 kilobytes of memory, was developed by IBM Germany for the DOS/360 low end operating system. It implements a subset of the PL/I language requiring all strings and arrays to have fixed extents, thus simplifying the run-time environment. Reflecting the underlying operating system, it lacks dynamic storage allocation and the "controlled" storage class. It was shipped within a year of PL/I F.
Multics PL/I and derivatives.
Compilers were implemented by several groups in the early 1960s. The Multics project at MIT, one of the first to develop an operating system in a high-level language, used Early PL/I (EPL), a subset dialect of PL/I, as their implementation language in 1964. EPL was developed at Bell Labs and MIT by Douglas McIlroy, Robert Morris, and others. The influential Multics PL/I compiler was the source of compiler technology used by a number of manufacturers and software groups. EPL was a system programming language and a dialect of PL/I that had some capabilities absent in the original PL/I (like varying length strings).
The Honeywell PL/I compiler (for Series 60) is an implementation of the full ANSI X3J1 standard.
IBM PL/I optimizing and checkout compilers.
The PL/I Optimizer and Checkout compilers produced in Hursley support a common level of PL/I language and aimed to replace the PL/I F compiler. The checkout compiler is a rewrite of PL/I F in BSL, IBM's PL/I-like proprietary implementation language (later PL/S). The performance objectives set for the compilers are shown in an IBM presentation to the BCS. The compilers had to produce identical results the Checkout Compiler is used to debug programs that would then be submitted to the Optimizer. Given that the compilers had entirely different designs and were handling the full PL/I language this goal was challenging: it was achieved.
The PL/I optimizing compiler took over from the PL/I F compiler and was IBM's workhorse compiler from the 1970s to the 1990s. Like PL/I F, it is a multiple pass compiler with a 44 kilobyte design point, but it is an entirely new design. Unlike the F compiler, it has to perform compile time evaluation of constant expressions using the run-time library, reducing the maximum memory for a compiler phase to 28 kilobytes. A second-time around design, it succeeded in eliminating the annoyances of PL/I F such as cascading diagnostics. It was written in S/360 Macro Assembler by a team, led by Tony Burbridge, most of whom had worked on PL/I F. Macros were defined to automate common compiler services and to shield the compiler writers from the task of managing real-mode storage, allowing the compiler to be moved easily to other memory models. The gamut of program optimization techniques developed for the contemporary IBM Fortran H compiler were deployed: the Optimizer equaled Fortran execution speeds in the hands of good programmers. Announced with IBM S/370 in 1970, it shipped first for the DOS/360 operating system in August 1971, and shortly afterward for OS/360, and the first virtual memory IBM operating systems OS/VS1, MVS, and VM/CMS. (The developers were unaware that while they were shoehorning the code into 28 kb sections, IBM Poughkeepsie was finally ready to ship virtual memory support in OS/360). It supported the batch programming environments and, under TSO and CMS, it could be run interactively. This compiler went through many versions covering all mainframe operating systems including the operating systems of the Japanese plug-compatible machines (PCMs).
The compiler has been superseded by "IBM PL/I for OS/2, AIX, Linux, z/OS" below.
The PL/I checkout compiler, (colloquially "The Checker") announced in August 1970 was designed to speed and improve the debugging of PL/I programs. The team was led by Brian Marks. The three-pass design cut the time to compile a program to 25% of that taken by the F Compiler. It can be run from an interactive terminal, converting PL/I programs into an internal format, "H-text". This format is interpreted by the Checkout compiler at run-time, detecting virtually all types of errors. Pointers are represented in 16 bytes, containing the target address and a description of the referenced item, thus permitting "bad" pointer use to be diagnosed. In a conversational environment when an error is detected, control is passed to the user who can inspect any variables, introduce debugging statements and edit the source program. Over time the debugging capability of mainframe programming environments developed most of the functions offered by this compiler and it was withdrawn (in the 1990s?)
DEC PL/I.
Perhaps the most commercially successful implementation aside from IBM's was Digital Equipment Corporation's VAX PL/I, later known as DEC PL/I. The implementation is "a strict superset of the ANSI X3.4-1981 PL/I General Purpose Subset and provides most of the features of the new ANSI X3.74-1987 PL/I General Purpose Subset", and was first released in 1988. It originally used a compiler backend named the VAX Code Generator (VCG) created by a team led by Dave Cutler. The front end was designed by Robert Freiburghouse, and was ported to the VAX from Multics. It runs on VMS on VAX and Alpha, and on Tru64. UniPrise Systems, Inc., was responsible for the compiler. Digital later sold the compiler to a third party, who marketed the compiler as Kednos PL/I until October 2016.
Teaching subset compilers.
In the late 1960s and early 1970s, many US and Canadian universities were establishing time-sharing services on campus and needed conversational compiler/interpreters for use in teaching science, mathematics, engineering, and computer science. Dartmouth was developing BASIC, but PL/I was a popular choice, as it was concise and easy to teach. As the IBM offerings were unsuitable, a number of schools built their own subsets of PL/I and their own interactive support. Examples are:
In the 1960s and early 1970s, Allen-Babcock implemented the Remote Users of Shared Hardware (RUSH) time sharing system for an IBM System/360 Model 50 with custom microcode and subsequently implemented IBM's CPS, an interactive time-sharing system for OS/360 aimed at teaching computer science basics, offered a limited subset of the PL/I language in addition to BASIC and a remote job entry facility.
PL/C, a dialect for teaching, a compiler developed at Cornell University, had the unusual capability of never failing to compile any program through the use of extensive automatic correction of many syntax errors and by converting any remaining syntax errors to output statements. The language was almost all of PL/I as implemented by IBM. PL/C was a very fast compiler.
 (Student Language/1, Student Language/One or Subset Language/1) was a PL/I subset, initially available late 1960s, that ran interpretively on the IBM 1130; instructional use was its strong point.
PLAGO, created at the Polytechnic Institute of Brooklyn, used a simplified subset of the PL/I language and focused on good diagnostic error messages and fast compilation times.
The Computer Systems Research Group of the University of Toronto produced the SP/k compilers which supported a sequence of subsets of PL/I called SP/1, SP/2, SP/3, ..., SP/8 for teaching programming. Programs that ran without errors under the SP/k compilers produced the same results under other contemporary PL/I compilers such as IBM's PL/I F compiler, IBM's checkout compiler or Cornell University's PL/C compiler.
Other examples are PL0 by P. Grouse at the University of New South Wales, PLUM by Marvin Zelkowitz at the University of Maryland., and PLUTO from the University of Toronto.
IBM PL/I for OS/2, AIX, Linux, z/OS.
In a major revamp of PL/I, IBM Santa Teresa in California launched an entirely new compiler in 1992. The initial shipment was for OS/2 and included most ANSI-G features and many new PL/I features. Subsequent releases covered additional platforms (MVS, VM, OS/390, AIX and Windows -although support for Windows has since been withdrawn) and continued to add functions to make PL/I fully competitive with other languages offered on the PC (particularly C and C++) in areas where it had been overtaken. The corresponding "IBM Language Environment" supports inter-operation of PL/I programs with Database and Transaction systems, and with programs written in C, C++, and COBOL, the compiler supports all the data types needed for intercommunication with these languages.
The PL/I design principles were retained and withstood this major extension comprising several new data types, new statements and statement options, new exception conditions, and new organisations of program source. The resulting language is a compatible super-set of the PL/I Standard and of the earlier IBM compilers. Major topics added to PL/I were:
The latest series of PL/I compilers for z/OS, called Enterprise PL/I for z/OS, leverage code generation for the latest z/Architecture processors (z14, z13, zEC12, zBC12, z196, z114) via the use of ARCHLVL parm control passed during compilation, and was the second High level language supported by z/OS Language Environment to do so (XL C/C++ being the first, and Enterprise COBOL v5 the last.)
Data types.
codice_30 is a new computational data type. The ordinal facilities are like those in Pascal,
e.g. codice_39
but in addition the name and internal values are accessible via built-in functions. Built-in functions provide access to an ordinal value's predecessor and successor.
The codice_40 (see below) allows additional codice_33s to be declared composed from PL/I's built-in attributes.
The codice_42 locator data type is similar to the codice_43 data type, but strongly typed to bind only to a particular data structure. The codice_44 operator is used to select a data structure using a handle.
The codice_34 attribute (equivalent to codice_46 in early PL/I specifications) permits several scalar variables, arrays, or structures to share the same storage in a unit that occupies the amount of storage needed for the largest alternative.
Competitiveness on PC and with C.
These attributes were added:
New string-handling functions were added to centre text, to edit using a picture format, and to trim blanks or selected characters from the head or tail of text, codice_63 to codice_64 from the right. and codice_65 and codice_66 functions.
Compound assignment operators a la C e.g. codice_67, codice_68, codice_69, codice_70 were added. codice_71 is equivalent to codice_72.
Additional parameter descriptors and attributes were added for omitted arguments and variable length argument lists.
Program readability – making intentions explicit.
The codice_73 attribute declares an identifier as a constant (derived from a specific literal value or restricted expression).
Parameters can have the codice_74 (pass by address) or codice_37 (pass by value) attributes.
The codice_76 and codice_77 attributes prevent unintended assignments.
codice_78 obviates the need for the contrived construct codice_79.
The codice_40 introduces user-specified names (e.g. codice_81) for combinations of built-in attributes (e.g. codice_82). Thus codice_83 creates the codice_33 name codice_81 as an alias for the set of built-in attributes FIXED BINARY(31.0). codice_31 applies to structures and their members; it provides a codice_33 name for a set of structure attributes and corresponding substructure member declarations for use in a structure declaration (a generalisation of the codice_88 attribute).
Structured programming additions.
A codice_89 statement to exit a loop, and an codice_90 to continue with the next iteration of a loop.
codice_56 and codice_57 options on iterative groups.
The package construct consisting of a set of procedures and declarations for use as a unit. Variables declared outside of the procedures are local to the package, and can use codice_93, codice_94 or codice_95 storage. Procedure names used in the package also are local, but can be made external by means of the codice_96 option of the codice_97.
Interrupt handling.
The codice_98 executed in an ON-unit terminates execution of the ON-unit, and raises the condition again in the procedure that called the current one (thus passing control to the corresponding ON-unit for that procedure).
The codice_99 condition handles invalid operation codes detected by the PC processor, as well as illegal arithmetic operations such as subtraction of two infinite values.
The codice_100 condition is provided to intercept conditions for which no specific ON-unit has been provided in the current procedure.
The codice_101 condition is raised when an codice_102 statement is unable to obtain sufficient storage.
Other mainframe and minicomputer compilers.
A number of vendors produced compilers to compete with IBM PL/I F or Optimizing compiler on mainframes and minicomputers in the 1970s. In the 1980s the target was usually the emerging ANSI-G subset.
Usage.
PL/I implementations were developed for mainframes from the late 1960s, mini computers in the 1970s, and personal computers in the 1980s and 1990s. Although its main use has been on mainframes, there are PL/I versions for DOS, Microsoft Windows, OS/2, AIX, OpenVMS, and Unix.
It has been widely used in business data processing and for system use for writing operating systems on certain platforms. Very complex and powerful systems have been built with PL/I:
PL/I did not fulfill its supporters' hopes that it would displace Fortran and COBOL and become the major player on mainframes. It remained a minority but significant player. There cannot be a definitive explanation for this, but some trends in the 1970s and 1980s militated against its success by progressively reducing the territory on which PL/I enjoyed a competitive advantage.
First, the nature of the mainframe software environment changed. Application subsystems for database and transaction processing (CICS and IMS and Oracle on System 370) and application generators became the focus of mainframe users' application development. Significant parts of the language became irrelevant because of the need to use the corresponding native features of the subsystems (such as tasking and much of input/output). Fortran was not used in these application areas, confining PL/I to COBOL's territory; most users stayed with COBOL. But as the PC became the dominant environment for program development, Fortran, COBOL and PL/I all became minority languages overtaken by C++, Java and the like.
Second, PL/I was overtaken in the system programming field. The IBM system programming community was not ready to use PL/I; instead, IBM developed and adopted a proprietary dialect of PL/I for system programming. – PL/S. With the success of PL/S inside IBM, and of C outside IBM, the unique PL/I strengths for system programming became less valuable.
Third, the development environments grew capabilities for interactive software development that, again, made the unique PL/I interactive and debugging strengths less valuable.
Fourth, COBOL and Fortran added features such as structured programming, character string operations, and object orientation, that further reduced PL/I's relative advantages.
On mainframes there were substantial business issues at stake too. IBM's hardware competitors had little to gain and much to lose from success of PL/I. Compiler development was expensive, and the IBM compiler groups had an in-built competitive advantage. Many IBM users wished to avoid being locked into proprietary solutions. With no early support for PL/I by other vendors it was best to avoid PL/I.
Evolution of the PL/I language.
This article uses the PL/I standard as the reference point for language features. But a number of features of significance in the early implementations were not in the Standard; and some were offered by non-IBM compilers. And the de facto language continued to grow after the standard, ultimately driven by developments on the Personal Computer.
Significant features omitted from the standard.
Multi tasking.
"Multi tasking" was implemented by PL/I F, the Optimizer and the newer AIX and Z/OS compilers. It comprised the data types codice_104 and codice_105, the codice_106 on the codice_107 (Fork), the codice_108 (Join), the codice_109, codice_110s on the record I/O statements and the codice_111 statement to unlock locked records on codice_112 files. Event data identify a particular event and indicate whether it is complete ('1'B) or incomplete ('0'B): task data items identify a particular task (or process) and indicate its priority relative to other tasks.
Preprocessor.
The first IBM "Compile time preprocessor" was built by the IBM Boston Advanced Programming Center located in Cambridge, Mass, and shipped with the PL/I F compiler. The codice_5 statement was in the Standard, but the rest of the features were not. The DEC and Kednos PL/I compilers implemented much the same set of features as IBM, with some additions of their own. IBM has continued to add preprocessor features to its compilers. The preprocessor treats the written source program as a sequence of tokens, copying them to an output source file or acting on them. When a % token is encountered the following compile time statement is executed: when an identifier token is encountered and the identifier has been codice_114d, codice_115d, and assigned a compile time value, the identifier is replaced by this value. Tokens are added to the output stream if they do not require action (e.g. codice_116), as are the values of ACTIVATEd compile time expressions. Thus a compile time variable codice_117 could be declared, activated, and assigned using codice_118. Subsequent occurrences of codice_117 would be replaced by codice_120.
The data type supported are codice_121 integers and codice_122 strings of varying length with no maximum length. The structure statements are:
and the simple statements, which also may have a [label-list:]
The feature allowed programmers to use identifiers for constants e.g. product part numbers or mathematical constants and was superseded in the standard by named constants for computational data. Conditional compiling and iterative generation of source code, possible with compile-time facilities, was not supported by the standard. Several manufacturers implemented these facilities.
Structured programming additions.
Structured programming additions were made to PL/I during standardization but were not accepted into the standard. These features were the codice_133 to exit from an iterative codice_4, the codice_135 and codice_136 added to codice_4, and a case statement of the general form:
codice_138&lt;br&gt;
These features were all included in IBM's PL/I Checkout and Optimizing compilers and in DEC PL/I.
Debug facilities.
PL/I F had offered some debug facilities that were not put forward for the standard but were implemented by others notably the CHECK(variable-list) condition prefix, codice_139 on-condition and the codice_140 option. The IBM Optimizing and Checkout compilers added additional features appropriate to the conversational mainframe programming environment (e.g. an codice_141 condition).
Significant features developed since the standard.
Several attempts had been made to design a structure member type that could have one of several datatypes (codice_46 in early IBM). With the growth of classes in programming theory, approaches to this became possible on a PL/I base codice_34, codice_33 etc. have been added by several compilers.
PL/I had been conceived in a single-byte character world. With support for Japanese and Chinese language becoming essential, and the developments on International Code Pages, the character string concept was expanded to accommodate wide non-ASCII/EBCDIC strings.
Time and date handling were overhauled to deal with the millennium problem, with the introduction of the DATETIME function that returned the date and time in one of about 35 different formats. Several other date functions deal with conversions to and from days and seconds.
Criticisms.
Implementation issues.
Though the language is easy to learn and use, implementing a PL/I compiler is difficult and time-consuming. A language as large as PL/I needed subsets that most vendors could produce and most users master. This was not resolved until "ANSI G" was published. The compile time facilities, unique to PL/I, took added implementation effort and additional compiler passes. A PL/I compiler was two to four times as large as comparable Fortran or COBOL compilers, and also that much slower—supposedly offset by gains in programmer productivity. This was anticipated in IBM before the first compilers were written.
Some argue that PL/I is unusually hard to parse. The PL/I "keywords" are not reserved so programmers can use them as variable or procedure names in programs. Because the original PL/I(F) compiler attempts "auto-correction" when it encounters a keyword used in an incorrect context, it often assumes it is a variable name. This leads to "cascading diagnostics", a problem solved by later compilers.
The effort needed to produce good object code was perhaps underestimated during the initial design of the language. Program optimization (needed to compete with the excellent program optimization carried out by available Fortran compilers) is unusually complex owing to side effects and pervasive problems with aliasing of variables. Unpredictable modification can occur asynchronously in exception handlers, which may be provided by "ON statements" in (unseen) callers. Together, these make it difficult to reliably predict when a program's variables might be modified at runtime. In typical use, however, user-written error handlers (the codice_145) often do not make assignments to variables. In spite of the aforementioned difficulties, IBM produced the PL/I Optimizing Compiler in 1971.
PL/I contains many rarely used features, such as multitasking support (an IBM extension to the language) which add cost and complexity to the compiler, and its co-processing facilities require a multi-programming environment with support for non-blocking multiple threads for processes by the operating system. Compiler writers were free to select whether to implement these features.
An undeclared variable is, by default, declared by first occurrence—thus misspelling might lead to unpredictable results. This "implicit declaration" is no different from FORTRAN programs. For PL/I(F), however, an attribute listing enables the programmer to detect any misspelled or undeclared variable.
Programmer issues.
Many programmers were slow to move from COBOL or Fortran due to a perceived complexity of the language and immaturity of the PL/I F compiler. Programmers were sharply divided into scientific programmers (who used Fortran) and business programmers (who used COBOL), with significant tension and even dislike between the groups. PL/I syntax borrowed from both COBOL and Fortran syntax. So instead of noticing features that would make their job easier, Fortran programmers of the time noticed COBOL syntax and had the opinion that it was a business language, while COBOL programmers noticed Fortran syntax and looked upon it as a scientific language.
Both COBOL and Fortran programmers viewed it as a "bigger" version of their own language, and both were somewhat intimidated by the language and disinclined to adopt it. Another factor was "pseudo"-similarities to COBOL, Fortran, and ALGOL. These were PL/I elements that looked similar to one of those languages, but worked differently in PL/I. Such frustrations left many experienced programmers with a jaundiced view of PL/I, and often an active dislike for the language. An early UNIX fortune file contained the following tongue-in-cheek description of the language:
Speaking as someone who has delved into the intricacies of PL/I, I am sure that only Real Men could have written such a machine-hogging, cycle-grabbing, all-encompassing monster. Allocate an array and free the middle third? Sure! Why not? Multiply a character string times a bit string and assign the result to a float decimal? Go ahead! Free a controlled variable procedure parameter and reallocate it before passing it back? Overlay three different types of variable on the same memory location? Anything you say! Write a recursive macro? Well, no, but Real Men use rescan. How could a language so obviously designed and written by Real Men not be intended for Real Man use?
On the positive side, full support for pointers to all data types (including pointers to structures), recursion, multitasking, string handling, and extensive built-in functions meant PL/I was indeed quite a leap forward compared to the programming languages of its time. However, these were not enough to persuade a majority of programmers or shops to switch to PL/I.
The PL/I F compiler's compile time preprocessor was unusual (outside the Lisp world) in using its target language's syntax and semantics ("e.g." as compared to the C preprocessor's "#" directives).
Special topics in PL/I.
Storage classes.
PL/I provides several 'storage classes' to indicate how the lifetime of variables' storage is to be managed codice_146 and codice_94. The simplest to implement is codice_93, which indicates that memory is allocated and initialized at load-time, as is done in COBOL "working-storage" and early Fortran. This is the default for codice_22 variables.
PL/I's default storage class for codice_150 variables is codice_151, similar to that of other block-structured languages influenced by ALGOL, like the "auto" storage class in the C language, and default storage allocation in Pascal and "local-storage" in IBM COBOL. Storage for codice_151 variables is allocated upon entry into the codice_153, procedure, or ON-unit in which they are declared. The compiler and runtime system allocate memory for a stack frame to contain them and other housekeeping information. If a variable is declared with an codice_154, code to set it to an initial value is executed at this time. Care is required to manage the use of initialization properly. Large amounts of code can be executed to initialize variables every time a scope is entered, especially if the variable is an array or structure. Storage for codice_151 variables is freed at block exit: codice_156 or codice_94 variables are used to retain variables' contents between invocations of a procedure or block. codice_95 storage is also managed using a stack, but the pushing and popping of allocations on the stack is managed by the programmer, using codice_102 and codice_160 statements. Storage for codice_94 variables is managed using codice_162, but instead of a stack these allocations have independent lifetimes and are addressed through codice_163 or codice_43 variables.
The codice_23 attribute is used to declare programmer-defined heaps. Data can be allocated and freed within a specific area, and the area can be deleted, read, and written as a unit.
Storage type sharing.
There are several ways of accessing allocated storage through different data declarations. Some of these are well defined and safe, some can be used safely with careful programming, and some are inherently unsafe and/or machine dependent.
Passing a variable as an argument to a parameter by reference allows the argument's allocated storage to be referenced using the parameter. The codice_166 attribute (e.g. codice_167) allows part or all of a variable's storage to be used with a different, but consistent, declaration. The language definition includes a codice_46 attribute (later renamed codice_34) to allow different definitions of data to share the same storage. This was not supported by many early IBM compilers. These usages are safe and machine independent.
Record I/O and list processing produce situations where the programmer needs to fit a declaration to the storage of the next record or item, before knowing what type of data structure it has. Based variables and pointers are key to such programs. The data structures must be designed appropriately, typically using fields in a data structure to encode information about its type and size. The fields can be held in the preceding structure or, with some constraints, in the current one. Where the encoding is in the preceding structure, the program needs to allocate a based variable with a declaration that matches the current item (using expressions for extents where needed). Where the type and size information are to be kept in the current structure ("self defining structures") the type-defining fields must be ahead of the type dependent items and in the same place in every version of the data structure. The codice_103-option is used for self-defining extents (e.g. string lengths as in codice_171 where codice_172 is used to allocate instances of the data structure. For self-defining structures, any typing and codice_173 fields are placed ahead of the "real" data. If the records in a data set, or the items in a list of data structures, are organised this way they can be handled safely in a machine independent way.
PL/I implementations do not (except for the PL/I Checkout compiler) keep track of the data structure used when storage is first allocated. Any codice_94 declaration can be used with a pointer into the storage to access the storage inherently unsafe and machine dependent. However, this usage has become important for "pointer arithmetic" (typically adding a certain amount to a known address). This has been a contentious subject in computer science. In addition to the problem of wild references and buffer overruns, issues arise due to the alignment and length for data types used with particular machines and compilers. Many cases where pointer arithmetic might be needed involve finding a pointer to an element inside a larger data structure. The codice_175 function computes such pointers, safely and machine independently.
Pointer arithmetic may be accomplished by aliasing a binary variable with a pointer as in 
codice_176 
It relies on pointers being the same length as codice_177 integers and aligned on the same boundaries.
With the prevalence of C and its free and easy attitude to pointer arithmetic, recent IBM PL/I compilers allow pointers to be used with the addition and subtraction operators to giving the simplest syntax (but compiler options can disallow these practices where safety and machine independence are paramount).
ON-units and exception handling.
When PL/I was designed, programs only ran in batch mode, with no possible intervention from the programmer at a terminal. An exceptional condition such as division by zero would abort the program yielding only a hexadecimal core dump. PL/I exception handling, via ON-units, allowed the program to stay in control in the face of hardware or operating system exceptions and to recover debugging information before closing down more gracefully. As a program became properly debugged, most of the exception handling could be removed or disabled: this level of control became less important when conversational execution became commonplace.
Computational exception handling is enabled and disabled by condition prefixes on statements, blocks(including ON-units) and procedures. – e.g. codice_178. Operating system exceptions for Input/Output and storage management are always enabled.
The ON-unit is a single statement or codice_179-block introduced by an codice_180. Executing the ON statement enables the condition specified, e.g., codice_181. When the exception for this condition occurs and the condition is enabled, the ON-unit for the condition is executed. ON-units are inherited down the call chain. When a block, procedure or ON-unit is activated, the ON-units established by the invoking activation are inherited by the new activation. They may be over-ridden by another codice_180 and can be reestablished by the codice_183. The exception can be simulated using the codice_184 – e.g. to help debug the exception handlers. The dynamic inheritance principle for ON-units allows a routine to handle the exceptions occurring within the subroutines it uses.
If no ON-unit is in effect when a condition is raised a standard system action is taken (often this is to raise the codice_25 condition). The system action can be reestablished using the codice_186 option of the codice_180. With some conditions it is possible to complete executing an ON-unit and return to the point of interrupt (e.g., the codice_188 conditions) and resume normal execution. With other conditions such as codice_189, the codice_25 condition is raised when this is attempted. An ON-unit may be terminated with a codice_191 preventing a return to the point of interrupt, but permitting the program to continue execution elsewhere as determined by the programmer.
An ON-unit needs to be designed to deal with exceptions that occur in the ON-unit itself. The codice_192 statement allows a nested error trap; if an error occurs within an ON-unit, control might pass to the operating system where a system dump might be produced, or, for some computational conditions, continue execution (as mentioned above).
The PL/I codice_193 I/O statements have relatively simple syntax as they do not offer options for the many situations from end-of-file to record transmission errors that can occur when a record is read or written. Instead, these complexities are handled in the ON-units for the various file conditions. The same approach was adopted for codice_23 sub-allocation and the codice_23 condition.
The existence of exception handling ON-units can have an effect on optimization, because variables can be inspected or altered in ON-units. Values of variables that might otherwise be kept in registers between statements, may need to be returned to storage between statements. This is discussed in the section on Implementation Issues above.
GO TO with a non-fixed target.
PL/I has counterparts for COBOL and FORTRAN's specialized GO TO statements.
Syntax for both COBOL and FORTRAN exist for coding two special two types of GO TO, each of which has a target that is not always the same.
PL/I has statement label variables (with the LABEL attribute), which can store the value of a statement label, and later be used in a GOTO statement. 
Statement label variables can be passed to called procedures, and used to return to a different statement in the calling routine.
Sample programs.
Hello world program.
Hello2: proc options(main);
 put list ('Hello, World!');
end Hello2;
Search for a string.
/* Read in a line, which contains a string,
/* and then print every subsequent line that contains that string. */
find_strings: procedure options (main);
 declare pattern character (100) varying;
 declare line character (100) varying;
 declare line_no fixed binary;
 on endfile (sysin) stop;
 get edit (pattern) (L);
 line_no = 1;
 do forever;
 get edit (line) (L);
 if index(line, pattern) &gt; 0 then
 put skip list (line_no, line);
 line_no = line_no + 1;
 end;
end find_strings;

