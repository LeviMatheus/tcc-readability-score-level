
In software development, obfuscation is the deliberate act of creating source or machine code that is difficult for humans to understand. Like obfuscation in natural language, it may use needlessly roundabout expressions to compose statements. Programmers may deliberately obfuscate code to conceal its purpose (security through obscurity) or its logic or implicit values embedded in it, primarily, in order to prevent tampering, deter reverse engineering, or even to create a puzzle or recreational challenge for someone reading the source code. This can be done manually or by using an automated tool, the latter being the preferred technique in industry.
Overview.
The architecture and characteristics of some languages may make them easier to obfuscate than others. C, C++, and the Perl programming language are some examples of languages easy to obfuscate. Haskell (programming language) is also quite obfuscatable despite being quite different in structure.
The properties that make a language obfuscatable are not immediately obvious.
Recreational obfuscation.
Writing and reading obfuscated source code can be a brain teaser. A number of programming contests reward the most creatively obfuscated code, such as the International Obfuscated C Code Contest and the Obfuscated Perl Contest.
Types of obfuscations include simple keyword substitution, use or non-use of whitespace to create artistic effects, and self-generating or heavily compressed programs.
According to Nick Montfort, techniques may include: 
Short obfuscated Perl programs may be used in signatures of Perl programmers. These are JAPHs ("Just another Perl hacker").
Examples.
This is a winning entry from the International Obfuscated C Code Contest written by Ian Phillipps in 1988 and subsequently reverse engineered by Thomas Ball.
/*
 LEAST LIKELY TO COMPILE SUCCESSFULLY:
 Ian Phillipps, Cambridge Consultants Ltd., Cambridge, England
main(t,_,a)
char
a;
 return!
0&lt;t?
t&lt;3?
main(-79,-13,a+
main(-87,1-_,
main(-86, 0, a+1 )
+a)):
1,
t&lt;_?
main(t+1, _, a )
main ( -94, -27+t, a )
&amp;&amp;t == 2 ?_
&lt;13 ?
main ( 2, _+1, "%s %d %d\n" )
t&lt;0?
t&lt;-72?
main( _, t,
"@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l,+,/n{n+,/+#n+,/#;\
q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# ){nl]!/n{n#'; \
r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#\
n'wk nw' iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c ;;\
t&lt;-50?
_==*a ?
putchar(31[a]):
main(-65,_,a+1)
main((*a == '/') + t, _, a + 1 ) 
0&lt;t?
main ( 2, 2 , "%s")
main(0,
main(-61,*a, "!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry")
It is a C program that when compiled and run will generate the 12 verses of "The 12 Days of Christmas". It contains all the strings required for the poem in an encoded form within the code.
A non-winning entry from the same year, this next example illustrates creative use of whitespace; it generates mazes of arbitrary length:
char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&amp;C);
-- E; J[ E] =T
[E ]= E) printf("._"); for(;(A-=Z=!Z) || (printf("\n|"
) , A = 39 ,C --
) ; Z || printf (M ))M[Z]=Z[A-(E =A[J-Z])&amp;&amp;!C
&amp; A == T[ A]
ANSI-compliant C compilers don't allow constant strings to be overwritten, which can be avoided by changing "*M" to "M[3]" and omitting "M=".
The following example by Óscar Toledo Gutiérrez, Best of Show entry in the 19th IOCCC, implements an 8080 emulator complete with terminal and disk controller, capable of booting CP/M-80 and running CP/M applications:
 #define n(o,p,e)=y=(z=a(e)%16 p x%16 p o,a(e)p x p o),h(
 #define s 6[o]
 #define p z=l[d(9)]|l[d(9)+1]«8,1&lt;(9[o]+=2)||++8[o]
 #define Q a(7)
 #define w 254&gt;(9[o]-=2)||--8[o],l[d(9)]=z,l[1+d(9)]=z»8
 #define O )):((
 #define b (y&amp;1?~s:s)»"\6\0\2\7"[y/2]&amp;1?0:(
 #define S )?(z-=
 #define a(f)*((7&amp;f)-6?&amp;o[f&amp;7]:&amp;l[d(5)])
 #define C S 5 S 3
 #define D(E)x/8!=16+E&amp;198+E*8!=x?
 #define B(C)fclose((C))
 #define q (c+=2,0[c-2]|1[c-2]«8)
 #define m x=64&amp;x?*c++:a(x),
 #define A(F)=fopen((F),"rb+")
 unsigned char o[10],l[78114],*c=l,*k=l
 #define d(e)o[e]+256*o[e-1]
+64506; e,V,v,u,x,y,z,Z; main(r,U)char**U;{
 for(v A((u A((e A((r-2?0:(V A(1[U])),"C")
),system("stty raw -echo min 0"),fread(l,78114,1,e),B(e),"B")),"A")); 118-(x
=*c++); (y=x/8%8,z=(x&amp;199)-4 S 1 S 1 S 186 S 2 S 2 S 3 S 0,r=(y&gt;5)*2+y,z=(x&amp;
207)-1 S 2 S 6 S 2 S 182 S 4)?D(0)D(1)D(2)D(3)D(4)D(5)D(6)D(7)(z=x-2 C C C C
C C C C+129 S 6 S 4 S 6 S 8 S 8 S 6 S 2 S 2 S 12)?x/64-1?((0 O a(y)=a(x) O 9
[o]=a(5),8[o]=a(4) O 237==*c++?((int (*)())(2-*c++?fwrite:fread))(l+*k+1[k]*
256,128,1,(fseek(y=5[k]-1?u:v,((3[k]|4[k]«8)«7|2[k])«7,Q=0),y)):0 O y=a(5
),z=a(4),a(5)=a(3),a(4)=a(2),a(3)=y,a(2)=z O c=l+d(5) O y=l[x=d(9)],z=l[++x]
,x[l]=a(4),l[--x]=a(5),a(5)=y,a(4)=z O 2-*c?Z||read(0,&amp;Z,1),1&amp;*c++?Q=Z,Z=0:(
Q=!!Z):(c++,Q=r=V?fgetc(V):-1,s=s&amp;~1|r&lt;0) O++c,write(1,&amp;7[o],1) O z=c+2-l,w,
c=l+q O p,c=l+z O c=l+q O s^=1 O Q=q[l] O s|=1 O q[l]=Q O Q=~Q O a(5)=l[x=q]
,a(4)=l[++x] O s|=s&amp;16|9&lt;Q%16?Q+=6,16:0,z=s|=1&amp;s|Q&gt;159?Q+=96,1:0,y=Q,h(s«8)
O l[x=q]=a(5),l[++x]=a(4) O x=Q%2,Q=Q/2+s%2*128,s=s&amp;~1|x O Q=l[d(3)]O x=Q /
128,Q=Q*2+s%2,s=s&amp;~1|x O l[d(3)]=Q O s=s&amp;~1|1&amp;Q,Q=Q/2|Q«7 O Q=l[d(1)]O s=~1
&amp;s|Q»7,Q=Q*2|Q»7 O l[d(1)]=Q O m y n(0,-,7)y) O m z=0,y=Q|=x,h(y) O m z=0,
y=Q^=x,h(y) O m z=Q*2|2*x,y=Q&amp;=x,h(y) O m Q n(s%2,-,7)y) O m Q n(0,-,7)y) O
m Q n(s%2,+,7)y) O m Q n(0,+,7)y) O z=r-8?d(r+1):s|Q«8,w O p,r-8?o[r+1]=z,r
[o]=z»8:(s=~40&amp;z|2,Q=z»8) O r[o]--||--o[r-1]O a(5)=z=a(5)+r[o],a(4)=z=a(4)
+o[r-1]+z/256,s=~1&amp;s|z»8 O ++o[r+1]||r[o]++O o[r+1]=*c++,r[o]=*c++O z=c-l,w
,c=y*8+l O x=q,b z=c-l,w,c=l+x) O x=q,b c=l+x) O b p,c=l+z) O a(y)=*c++O r=y
,x=0,a(r)n(1,-,y)s«8) O r=y,x=0,a(r)n(1,+,y)s«8))));
An example of a JAPH:
@P=split//,".URRUU\c8R";@d=split//,"\nrekcah xinU / lreP rehtona tsuJ";sub p{
@p{"r$p","u$p"}=(P,P);pipe"r$p","u$p";++$p;($q*=2)+=$f=!fork;map{$P=$P[$f^ord
($p{$_})&amp;6];$p{$_}=/ ^$P/ix?$P:close$_}keys%p}p;p;p;p;p;map{$p{$_}=~/^[P.]/&amp;&amp;
close$_}%p;wait until$?;map{/^r/&amp;&amp;&lt;$_&gt;}%p;$_=$d[$q];sleep rand(2)if/\S/;print
This slowly displays the text "Just another Perl / Unix hacker", multiple characters at a time, with delays. An explanation can be found here.
Some Python examples can be found in the official Python programming FAQ and elsewhere.
Advantages of obfuscation.
Faster loading time.
The scripts used by web-pages have to be sent over the network to the user agent that shall run them. The smaller they are, the faster the download. In such use-cases, minification (a relatively trivial form of obfuscation) can produce real advantages.
Reduced memory usage.
In antique run-time interpreted languages (more commonly known as script), like older versions of BASIC, programs executed faster and took less RAM if they used single letter variable names, avoided comments and contained only necessary blank characters (in brief, the shorter the faster).
Protection for trade secrets.
Where the source code of a program must be sent to the user, for example JavaScript in a web page, any trade secret, licensing mechanism or other intellectual property contained within the program is accessible to the user. Obfuscation makes it harder to understand the code and make modifications to it.
Desktop programs sometimes include features that help to obfuscate their code. Some programs may not store their entire code on disk, and may pull a portion of their binary code via the web at runtime. They may also use compression and/or encryption, adding additional steps to the disassembly process.
Prevention of circumvention.
Obfuscating the program can, in such cases, make it harder for users to circumvent license mechanisms or obtain information the program's supplier wished to hide. It can also be used to make it harder to hack multiplayer games.
Prevention of virus detection.
Malicious programs may use obfuscation to disguise what they are really doing. Most users don't even read such programs; and those that do typically have access to software tools that can help them to undo the obfuscation, so this strategy is of limited efficacy.
Decompilers.
A decompiler can reverse-engineer source code from an executable or library. Decompilation is sometimes called a man-at-the-end attack, based on the traditional cryptographic attack known as "man-in-the-middle". It puts source code in the hands of the user, although this source code is often difficult to read. The source code is likely to have random function and variable names, incorrect variable types, and use different logic than the original source code (due to compiler optimizations).
Cryptographic obfuscation.
Recently, cryptographers have explored the idea of obfuscating code so that reverse-engineering the code is "cryptographically" hard. This is formalized in the many proposals for indistinguishability obfuscation, a cryptographic primitive that, if possible to build securely, would allow one to construct many other kinds of cryptography, including completely novel types that no one knows how to make. (A stronger notion, black-box obfuscation, was shown impossible in 2001 when researchers constructed programs that cannot be obfuscated in this notion.)
Notifying users of obfuscated code.
Some anti-virus softwares, such as AVG AntiVirus, will also alert their users when they land on a website with code that is manually obfuscated, as one of the purposes of obfuscation can be to hide malicious code. However, some developers may employ code obfuscation for the purpose of reducing file size or increasing security. The average user may not expect their antivirus software to provide alerts about an otherwise harmless piece of code, especially from trusted corporations, so such a feature may actually deter users from using legitimate software.
Certain major browsers such as Firefox and Chrome also disallow browser extensions containing obfuscated code.
Obfuscating software.
A variety of tools exist to perform or assist with code obfuscation. These include experimental research tools created by academics, hobbyist tools, commercial products written by professionals, and open-source software. Deobfuscation tools also exist that attempt to perform the reverse transformation.
Although the majority of commercial obfuscation solutions work by transforming either program source code, or platform-independent bytecode as used by Java and .NET, there are also some that work directly on compiled binaries.
Obfuscation and copyleft licenses.
There has been debate on whether it is illegal to skirt copyleft software licenses by releasing source code in obfuscated form, such as in cases in which the author is less willing to make the source code available. The issue is addressed in the GNU General Public License by requiring the "preferred form for making modifications" to be made available. The GNU website states "Obfuscated 'source code' is not real source code and does not count as source code."

