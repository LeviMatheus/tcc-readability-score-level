
The unary numeral system is the simplest numeral system to represent natural numbers: to represent a number "N", a symbol representing 1 is repeated "N" times.
In the unary system, the number 0 (zero) is represented by the empty string, that is, the absence of a symbol. Numbers 1, 2, 3, 4, 5, 6, ... are represented in unary as 1, 11, 111, 1111, 11111, 111111, ...
In the positional notation framework, the unary is the bijective base-1 numeral system. However, because the value of a digit does not depend on its position, one can argue that unary is not a positional system.
The use of tally marks in counting is an application of the unary numeral system. For example, using the tally mark |, the number 3 is represented as |||. In East Asian cultures, the number 3 is represented as 三, a character drawn with three strokes. (One and two are represented similarly.) In China and Japan, the character 正, drawn with 5 strokes, is sometimes used to represent 5 as a tally.
Unary numbers should be distinguished from repunits, which are also written as sequences of ones but have their usual decimal numerical interpretation.
Operations.
Addition and subtraction are particularly simple in the unary system, as they involve little more than string concatenation. The Hamming weight or population count operation that counts the number of nonzero bits in a sequence of binary values may also be interpreted as a conversion from unary to binary numbers. However, multiplication is more cumbersome and has often been used as a test case for the design of Turing machines.
Complexity.
Compared to standard positional numeral systems, the unary system is inconvenient and hence is not used in practice for large calculations. It occurs in some decision problem descriptions in theoretical computer science (e.g. some P-complete problems), where it is used to "artificially" decrease the run-time or space requirements of a problem. For instance, the problem of integer factorization is suspected to require more than a polynomial function of the length of the input as run-time if the input is given in binary, but it only needs linear runtime if the input is presented in unary. However, this is potentially misleading. Using a unary input is slower for any given number, not faster; the distinction is that a binary (or larger base) input is proportional to the base 2 (or larger base) logarithm of the number while unary input is proportional to the number itself. Therefore, while the run-time and space requirement in unary looks better as function of the input size, it does not represent a more efficient solution.
In computational complexity theory, unary numbering is used to distinguish strongly NP-complete problems from problems that are NP-complete but not strongly NP-complete. A problem in which the input includes some numerical parameters is strongly NP-complete if it remains NP-complete even when the size of the input is made artificially larger by representing the parameters in unary. For such a problem, there exist hard instances for which all parameter values are at most polynomially large.
Applications.
Unary numbering is used as part of some data compression algorithms such as Golomb coding. It also forms the basis for the Peano axioms for formalizing arithmetic within mathematical logic.
A form of unary notation called Church encoding is used to represent numbers within lambda calculus.

