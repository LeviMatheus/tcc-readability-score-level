
Computerized batch processing is the running of "jobs that can run without end user interaction, or can be scheduled to run as resources permit."
History.
The term "batch processing" originates in the traditional classification of methods of production as job production (one-off production), batch production (production of a "batch" of multiple items at once, one stage at a time), and flow production (mass production, all stages in process at once).
Early history.
Early computers were capable of running only one program at a time. Each user had sole control of the machine for a scheduled period of time. They would arrive at the computer with program and data, often on punched paper cards and magnetic or paper tape, and would load their program, run and debug it, and carry off their output when done.
As computers became faster the setup and takedown time became a larger percentage of available computer time. Programs called "monitors", the forerunners of operating systems, were developed which could process a series, or "batch", of programs, often from magnetic tape prepared offline. The monitor would be loaded into the computer and run the first job of the batch. At the end of the job it would regain control and load and run the next until the batch was complete. Often the output of the batch would be written to magnetic tape and printed or punched offline. Examples of monitors were IBM's "Fortran Monitor System", SOS (Share Operating System),
and finally IBSYS for IBM's 709x systems in 1960.
Third-generation systems.
Third-generation computers capable of multiprogramming began to appear in the 1960s. Instead of running one batch job at a time, these systems can have multiple batch programs running at the same time in order to keep the system as busy as possible. One or more programs might be awaiting input, one actively running on the CPU, and others generating output. Instead of offline input and output, programs called spoolers read jobs from cards, disk, or remote terminals and place them in a job queue to be run. In order to prevent deadlocks the job scheduler needs to know each job's resource requirementsâ€”memory, magnetic tapes, mountable disks, etc., so various scripting languages were developed to supply this information in a structured way. Probably the most well-known is IBM's "Job Control Language" (JCL). Job schedulers select jobs to run according to a variety of criteria, including priority, memory size, etc. Remote batch is a procedure for submitting batch jobs from remote terminals, often equipped with a punch card reader and a line printer. Sometimes asymmetric multiprocessing is used to spool batch input and output for one or more large computers using an attached smaller and less-expensive system, as in the IBM System/360 Attached Support Processor.
Later history.
From the late 1960s onwards, interactive computing such as via text-based computer terminal interfaces (as in Unix shells or read-eval-print loops), and later graphical user interfaces became common. Non-interactive computation, both one-off jobs such as compilation, and processing of multiple items in batches, became retrospectively referred to as "batch processing", and the term "batch job" (in early use often "batch "of" jobs") became common. Early use is 
particularly found at the University of Michigan, around the Michigan Terminal System (MTS).
Although timesharing did exist, its use was not robust enough for corporate data processing; none of this was related to the earlier unit record equipment, which was human-operated.
Ongoing.
Non-interactive computation remains pervasive in computing, both for general data processing and for system "housekeeping" tasks (using system software). A high-level program (executing multiple programs, with some additional "glue" logic) is today most often called a "script", and written in scripting languages, particularly shell scripts for system tasks; in IBM PC DOS and MS-DOS this is instead known as a batch file. That includes UNIX-based computers, Microsoft Windows, macOS (whose foundation is the BSD Unix kernel), and even smartphones. A running script, particularly one executed from an interactive login session, is often known as a job, but that term is used very ambiguously.
"There is no direct counterpart to z/OS batch processing in PC or UNIX systems. Batch jobs are typically executed at a scheduled time or on an as-needed basis. Perhaps the closest comparison is with processes run by an AT or CRON command in UNIX, although the differences are significant."
Modern systems.
Batch applications are still critical in most organizations in large part because many common business processes are amenable to batch processing. While online systems can also function when manual intervention is not desired, they are not typically optimized to perform high-volume, repetitive tasks. Therefore, even new systems usually contain one or more batch applications for updating information at the end of the day, generating reports, printing documents, and other non-interactive tasks that must complete reliably within certain business deadlines.
Some applications are amenable to flow processing, namely those that only need data from a single input at once (not totals, for instance): start the next step for each input as it completes the previous step. In this case flow processing lowers latency for individual inputs, allowing them to be completed without waiting for the entire batch to finish. However, many applications require data from all records, notably computations such as totals. In this case the entire batch must be completed before one has a usable result: partial results are not usable.
Modern batch applications make use of modern batch frameworks such as Jem The Bee, Spring Batch or implementations of JSR 352 written for Java, and other frameworks for other programming languages, to provide the fault tolerance and scalability required for high-volume processing. In order to ensure high-speed processing, batch applications are often integrated with grid computing solutions to partition a batch job over a large number of processors, although there are significant programming challenges in doing so. High volume batch processing places particularly heavy demands on system and application architectures as well. Architectures that feature strong input/output performance and vertical scalability, including modern mainframe computers, tend to provide better batch performance than alternatives.
Scripting languages became popular as they evolved along with batch processing.
Batch window.
A "batch window" is "a period of less-intensive online activity", when the computer system is able to run batch jobs without interference from, or with, interactive online systems.
A bank's "end-of-day (EOD)" jobs require the concept of "cutover", where transaction and data are cut off for a particular day's batch activity ("deposits after 3 PM will be processed the next day").
As requirements for online systems uptime expanded to support globalization, the Internet, and other business needs, the batch window shrank and increasing emphasis was placed on techniques that would require online data to be available for a maximum amount of time.
Batch size.
The "batch size" refers to the number of work units to be processed within one batch operation. Some examples are:
Notable batch scheduling and execution environments.
The IBM mainframe z/OS operating system or platform has arguably the most highly refined and evolved set of batch processing facilities owing to its origins, long history, and continuing evolution. Today such systems commonly support hundreds or even thousands of concurrent online and batch tasks within a single operating system image. Technologies that aid concurrent batch and online processing include Job Control Language (JCL), scripting languages such as REXX, Job Entry Subsystem (JES2 and JES3), Workload Manager (WLM), Automatic Restart Manager (ARM), Resource Recovery Services (RRS), DB2 data sharing, Parallel Sysplex, unique performance optimizations such as HiperDispatch, I/O channel architecture, and several others.
The Unix programs codice_1, codice_2, and codice_3 (today codice_3 is a variant of codice_2) allow for complex scheduling of jobs. Windows has a job scheduler. Most high-performance computing clusters use batch processing to maximize cluster usage.

