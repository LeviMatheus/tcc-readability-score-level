
In mathematics and computer science, currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument. For example, currying a function formula_1 that takes three arguments creates three functions:
formula_2
Or more abstractly, a function that takes two arguments, one from formula_3 and one from formula_4, and produces outputs in formula_5 by currying is translated into a function that takes a single argument from formula_3 and produces as outputs "functions" from formula_4 to formula_8 Currying is related to, but not the same as, partial application.
Currying is useful in both practical and theoretical settings. In functional programming languages, and many others, it provides a way of automatically managing how arguments are passed to functions and exceptions. In theoretical computer science, it provides a way to study functions with multiple arguments in simpler theoretical models which provide only one argument. The most general setting for the strict notion of currying and uncurrying is in the closed monoidal categories, which underpins a vast generalization of the Curry–Howard correspondence of proofs and programs to a correspondence with many other structures, including quantum mechanics, cobordisms and string theory. It was introduced by Gottlob Frege, developed by Moses Schönfinkel,
and further developed by Haskell Curry.
Uncurrying is the dual transformation to currying, and can be seen as a form of defunctionalization. It takes a function formula_1 whose return value is another function formula_10, and yields a new function formula_11 that takes as parameters the arguments for both formula_1 and formula_10, and returns, as a result, the application of formula_1 and subsequently, formula_10, to those arguments. The process can be iterated.
Motivation.
Currying provides a way for working with functions that take multiple arguments, and using them in frameworks where functions might take only one argument. For example, some analytical techniques can only be applied to functions with a single argument. Practical functions frequently take more arguments than this. Frege showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying. All "ordinary" functions that might typically be encountered in mathematical analysis or in computer programming can be curried. However, there are categories in which currying is not possible; the most general categories which allow currying are the closed monoidal categories.
Some programming languages almost always use curried functions to achieve multiple arguments; notable examples are ML and Haskell, where in both cases all functions have exactly one argument. This property is inherited from lambda calculus, where multi-argument functions are usually represented in curried form.
Currying is related to, but not the same as partial application. In practice, the programming technique of closures can be used to perform partial application and a kind of currying, by hiding arguments in an environment that travels with the curried function.
Illustration.
Suppose we have a function formula_16 which takes two real number (formula_17) arguments and outputs real numbers, and it is defined by formula_18. Currying translates this into a function formula_19 which takes a single real argument and outputs functions from formula_17 to formula_17. In symbols, formula_22, where formula_23denotes the set of all functions that take a single real argument and produce real outputs. For every real number formula_24, define the function formula_25 by formula_26, and then define the function formula_22 by formula_28. So for instance, formula_29 is the function that sends its real argument formula_30 to the output formula_31, or formula_32. We see that in general 
so that the original function formula_1 and its currying formula_19 convey exactly the same information. In this situation, we also write 
This also works for functions with more than two arguments. If formula_1 were a function of three arguments formula_38, its currying formula_19 would have the property
History.
The name "currying", coined by Christopher Strachey in 1967, is a reference to logician Haskell Curry. The alternative name "Schönfinkelisation" has been proposed as a reference to Moses Schönfinkel. In the mathematical context, the principle can be traced back to work in 1893 by Frege.
Definition.
Currying is most easily understood by starting with an informal definition, which can then be molded to fit many different domains. First, there is some notation to be established. The notation formula_41 denotes all functions from formula_3 to formula_4. If formula_1 is such a function, we write formula_45. Let formula_46 denote the ordered pairs of the elements of formula_3 and formula_4 respectively, that is, the Cartesian product of formula_3 and formula_4. Here, formula_3 and formula_4 may be sets, or they may be types, or they may be other kinds of objects, as explored below. 
Given a function
currying constructs a new function
That is, formula_55 takes an argument from formula_3 and returns a function that maps formula_4 to formula_58. It is defined by
for formula_24 from formula_3 and formula_30 from formula_4. We then also write
Uncurrying is the reverse transformation, and is most easily understood in terms of its right adjoint, the function formula_65
Set theory.
In set theory, the notation formula_66 is used to denote the set of functions from the set formula_3 to the set formula_4. Currying is the natural bijection between the set formula_69 of functions from formula_70 to formula_71, and the set formula_72 of functions from formula_73 to the set of functions from formula_74 to formula_71. In symbols:
Indeed, it is this natural bijection that justifies the exponential notation for the set of functions. As is the case in all instances of currying, the formula above describes an adjoint pair of functors: for every fixed set formula_74, the functor formula_78 is left adjoint to the functor formula_79.
In the category of sets, the object formula_66 is called the exponential object.
Function spaces.
In the theory of function spaces, such as in functional analysis or homotopy theory, one is commonly interested in continuous functions between topological spaces. One writes formula_81 (the Hom functor) for the set of "all" functions from formula_3 to formula_4, and uses the notation formula_66 to denote the subset of continuous functions. Here, formula_85 is the bijection
while uncurrying is the inverse map. If the set formula_66 of continuous functions from formula_3 to formula_4 is given the compact-open topology, and if the space formula_4 is locally compact Hausdorff, then
is a homeomorphism. This is also the case when formula_3, formula_4 and formula_66 are compactly generated, although there are more cases.
One useful corollary is that a function is continuous if and only if its curried form is continuous. Another important result is that the application map, usually called "evaluation" in this context, is continuous (note that eval is a strictly different concept in computer science.) That is,
formula_95
is continuous when formula_66 is compact-open and formula_4 locally compact Hausdorff. These two results are central for establishing the continuity of homotopy, i.e. when formula_3 is the unit interval formula_99, so that formula_100 can the thought of as either a homotopy of two functions from formula_4 to formula_58, or, equivalently, a single (continuous) path in formula_103.
Algebraic topology.
In algebraic topology, currying serves as an example of Eckmann–Hilton duality, and, as such, plays an important role in a variety of different settings. For example, loop space is adjoint to reduced suspensions; this is commonly written as
where formula_105 is the set of homotopy classes of maps formula_106, and formula_107 is the suspension of "A", and formula_108 is the loop space of "A". In essence, the suspension formula_109 can be seen as the cartesian product of formula_3 with the unit interval, modulo an equivalence relation to turn the interval into a loop. The curried form then maps the space formula_3 to the space of functions from loops into formula_58, that is, from formula_3 into formula_114. Then formula_85 is the adjoint functor that maps suspensions to loop spaces, and uncurrying is the dual.
The duality between the mapping cone and the mapping fiber (cofibration and fibration) can be understood as a form of currying, which in turn leads to the duality of the long exact and coexact Puppe sequences.
In homological algebra, the relationship between currying and uncurrying is known as tensor-hom adjunction. Here, an interesting twist arises: the Hom functor and the tensor product functor might not lift to an exact sequence; this leads to the definition of the Ext functor and the Tor functor.
Domain theory.
In order theory, that is, the theory of lattices of partially ordered sets, formula_85 is a continuous function when the lattice is given the Scott topology. Scott-continuous functions were first investigated in the attempt to provide a semantics for lambda calculus (as ordinary set theory is inadequate to do this). More generally, Scott-continuous functions are now studied in domain theory, which encompasses the study of denotational semantics of computer algorithms. Note that the Scott topology is quite different than many common topologies one might encounter in the category of topological spaces; the Scott topology is typically finer, and is not sober.
The notion of continuity makes its appearance in homotopy type theory, where, roughly speaking, two computer programs can be considered to be homotopic, i.e. compute the same results, if they can be "continuously" refactored from one to the other.
Lambda calculi.
In theoretical computer science, currying provides a way to study functions with multiple arguments in very simple theoretical models, such as the lambda calculus, in which functions only take a single argument. Consider a function formula_117 taking two arguments, and having the type formula_118, which should be understood to mean that "x" must have the type formula_3, "y" must have the type formula_4, and the function itself returns the type formula_58. The curried form of "f" is defined as
where formula_123 is the abstractor of lambda calculus. Since curry takes, as input, functions with the type formula_124, one concludes that the type of curry itself is
The → operator is often considered right-associative, so the curried function type formula_126 is often written as formula_127. Conversely, function application is considered to be left-associative, so that formula_128 is equivalent to
That is, the parenthesis are not required to disambiguate the order of the application.
Curried functions may be used in any programming language that supports closures; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.
Type theory.
In type theory, the general idea of a type system in computer science is formalized into a specific algebra of types. For example, when writing formula_45, the intent is that formula_3 and formula_4 are types, while the arrow formula_133 is a type constructor, specifically, the function type or arrow type. Similarly, the Cartesian product formula_46 of types is constructed by the product type constructor formula_135.
The type-theoretical approach is expressed in programming languages such as ML and the languages derived from and inspired by it: CaML, Haskell and F#.
The type-theoretical approach provides a natural complement to the language of category theory, as discussed below. This is because categories, and specifically, monoidal categories, have an internal language, with simply-typed lambda calculus being the most prominent example of such a language. It is important in this context, because it can be built from a single type constructor, the arrow type. Currying then endows the language with a natural product type. The correspondence between objects in categories and types then allows programming languages to be re-interpreted as logics (via Curry–Howard correspondence), and as other types of mathematical systems, as explored further, below.
Logic.
Under the Curry–Howard correspondence, the existence of currying and uncurrying is equivalent to the logical theorem formula_136, as tuples (product type) corresponds to conjunction in logic, and function type corresponds to implication.
The exponential object formula_137 in the category of Heyting algebras is normally written as material implication formula_138. Distributive Heyting algebras are Boolean algebras, and the exponential object has the explicit form formula_139, thus making it clear that the exponential object really is material implication.
Category theory.
The above notions of currying and uncurrying find their most general, abstract statement in category theory. Currying is a universal property of an exponential object, and gives rise to an adjunction in cartesian closed categories. That is, there is a natural isomorphism between the morphisms from a binary product formula_53 and the morphisms to an exponential object formula_141. 
This generalizes to a broader result in closed monoidal categories: Currying is the statement that the tensor product and the internal Hom are adjoint functors; that is, for every object formula_73 there is a natural isomorphism: 
Here, "Hom" denotes the (external) Hom-functor of all morphisms in the category, while formula_144 denotes the internal hom functor in the closed monoidal category. For the category of sets, the two are the same. When the product is the cartesian product, then the internal hom formula_144 becomes the exponential object formula_146.
Currying can break down in one of two ways. One is if a category is not closed, and thus lacks an internal hom functor (possibly because there is more than one choice for such a functor). Another way is if it is not monoidal, and thus lacks a product (that is, lacks a way of writing down pairs of objects). Categories that do have both products and internal homs are exactly the closed monoidal categories.
The setting of cartesian closed categories is sufficient for the discussion of classical logic; the more general setting of closed monoidal categories is suitable for quantum computation.
The difference between these two is that the product for cartesian categories (such as the category of sets, complete partial orders or Heyting algebras) is just the Cartesian product; it is interpreted as an ordered pair of items (or a list). Simply typed lambda calculus is the internal language of cartesian closed categories; and it is for this reason that pairs and lists are the primary types in the type theory of LISP, scheme and many functional programming languages.
By contrast, the product for monoidal categories (such as Hilbert space and the vector spaces of functional analysis) is the tensor product. The internal language of such categories is linear logic, a form of quantum logic; the corresponding type system is the linear type system. Such categories are suitable for describing entangled quantum states, and, more generally, allow a vast generalization of the Curry–Howard correspondence to quantum mechanics, to cobordisms in algebraic topology, and to string theory. The linear type system, and linear logic are useful for describing synchronization primitives, such as mutual exclusion locks, and the operation of vending machines.
Contrast with partial function application.
Currying and partial function application are often conflated. One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose arity is greater than two.
Given a function of type formula_147, currying produces formula_148. That is, while an evaluation of the first function might be represented as formula_149, evaluation of the curried function would be represented as formula_150, applying each argument in turn to a single-argument function returned by the previous invocation. Note that after calling formula_151, we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.
In contrast, partial function application refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. Given the definition of formula_1 above, we might fix (or 'bind') the first argument, producing a function of type formula_153. Evaluation of this function might be represented as formula_154. Note that the result of partial function application in this case is a function that takes two arguments.
Intuitively, partial function application says "if you fix the first argument of the function, you get a function of the remaining arguments". For example, if function "div" stands for the division operation "x"/"y", then "div" with the parameter "x" fixed at 1 (i.e., "div" 1) is another function: the same as the function "inv" that returns the multiplicative inverse of its argument, defined by "inv"("y") = 1/"y".
The practical motivation for partial application is that very often the functions obtained by supplying some but not all of the arguments to a function are useful; for example, many languages have a function or operator similar to codice_1. Partial application makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.
Partial application can be seen as evaluating a curried function at a fixed point, e.g. given formula_147 and formula_156 then formula_157 or simply formula_158 where formula_159 curries f's first parameter. 
Thus, partial application is reduced to a curried function at a fixed point. Further, a curried function at a fixed point is (trivially), a partial application. For further evidence, note that, given any function formula_117, a function formula_161 may be defined such that formula_162. Thus, any partial application may be reduced to a single curry operation. As such, curry is more suitably defined as an operation which, in many theoretical cases, is often applied recursively, but which is theoretically indistinguishable (when considered as an operation) from a partial application.
So, a partial application can be defined as the objective result of a single application of the curry operator on some ordering of the inputs of some function.

