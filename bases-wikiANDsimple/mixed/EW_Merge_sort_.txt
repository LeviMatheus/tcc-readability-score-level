
In computer science, merge sort (also commonly spelled as mergesort) is an efficient, general-purpose, and comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the order of equal elements is the same in the input and output. Merge sort is a divide and conquer algorithm that was invented by John von Neumann in 1945. A detailed description and analysis of bottom-up merge sort appeared in a report by Goldstine and von Neumann as early as 1948.
Algorithm.
Conceptually, a merge sort works as follows:
Top-down implementation.
Example C-like code using indices for top-down merge sort algorithm that recursively splits the list (called "runs" in this example) into sublists until sublist size is 1, then merges those sublists to produce a sorted list. The copy back step is avoided with alternating the direction of the merge with each level of recursion (except for an initial one-time copy). To help understand this, consider an array with 2 elements. The elements are copied to B[], then merged back to A[]. If there are 4 elements, when the bottom of the recursion level is reached, single element runs from A[] are merged to B[], and then at the next higher level of recursion, those 2 element runs are merged to A[]. This pattern continues with each level of recursion.
// Array A[] has the items to sort; array B[] is a work array.
void TopDownMergeSort(A[], B[], n)
 CopyArray(A, 0, n, B); // one time copy of A[] to B[]
 TopDownSplitMerge(B, 0, n, A); // sort data from B[] into A[]
// Split A[] into 2 runs, sort both runs into B[], merge both runs from B[] to A[]
// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).
void TopDownSplitMerge(B[], iBegin, iEnd, A[])
 if(iEnd - iBegin &lt;= 1) // if run size == 1
 return; // consider it sorted
 // split the run longer than 1 item into halves
 iMiddle = (iEnd + iBegin) / 2; // iMiddle = mid point
 // recursively sort both runs from array A[] into B[]
 TopDownSplitMerge(A, iBegin, iMiddle, B); // sort the left run
 TopDownSplitMerge(A, iMiddle, iEnd, B); // sort the right run
 // merge the resulting runs from array B[] into A[]
 TopDownMerge(B, iBegin, iMiddle, iEnd, A);
// Left source half is A[ iBegin:iMiddle-1].
// Right source half is A[iMiddle:iEnd-1 ].
// Result is B[ iBegin:iEnd-1 ].
void TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])
 i = iBegin, j = iMiddle;
 // While there are elements in the left or right runs...
 for (k = iBegin; k &lt; iEnd; k++) {
 // If left run head exists and is &lt;= existing right run head.
 if (i &lt; iMiddle &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) {
 B[k] = A[i];
 i = i + 1;
 } else {
 B[k] = A[j];
 j = j + 1;
void CopyArray(A[], iBegin, iEnd, B[])
 for(k = iBegin; k &lt; iEnd; k++)
 B[k] = A[k];
Sorting the entire array is accomplished by .
Bottom-up implementation.
Example C-like code using indices for bottom-up merge sort algorithm which treats the list as an array of "n" sublists (called "runs" in this example) of size 1, and iteratively merges sub-lists back and forth between two buffers:
// array A[] has the items to sort; array B[] is a work array
void BottomUpMergeSort(A[], B[], n)
 // Each 1-element run in A is already "sorted".
 // Make successively longer sorted runs of length 2, 4, 8, 16... until the whole array is sorted.
 for (width = 1; width &lt; n; width = 2 * width)
 // Array A is full of runs of length width.
 for (i = 0; i &lt; n; i = i + 2 * width)
 // Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[]
 // or copy A[i:n-1] to B[] ( if(i+width &gt;= n) )
 BottomUpMerge(A, i, min(i+width, n), min(i+2*width, n), B);
 // Now work array B is full of runs of length 2*width.
 // Copy array B to array A for the next iteration.
 // A more efficient implementation would swap the roles of A and B.
 CopyArray(B, A, n);
 // Now array A is full of runs of length 2*width.
// Left run is A[iLeft :iRight-1].
// Right run is A[iRight:iEnd-1 ].
void BottomUpMerge(A[], iLeft, iRight, iEnd, B[])
 i = iLeft, j = iRight;
 // While there are elements in the left or right runs...
 for (k = iLeft; k &lt; iEnd; k++) {
 // If left run head exists and is &lt;= existing right run head.
 if (i &lt; iRight &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) {
 B[k] = A[i];
 i = i + 1;
 } else {
 B[k] = A[j];
 j = j + 1; 
 } 
void CopyArray(B[], A[], n)
 for(i = 0; i &lt; n; i++)
 A[i] = B[i];
Top-down implementation using lists.
Pseudocode for top-down merge sort algorithm which recursively divides the input list into smaller sublists until the sublists are trivially sorted, and then merges the sublists while returning up the call chain.
 function merge_sort("list" m) is
 // "Base case. A list of zero or one elements is sorted, by definition."
 if length of m ≤ 1 then
 return m
 // "Recursive case. First, divide the list into equal-sized sublists"
 // "consisting of the first half and second half of the list."
 // "This assumes lists start at index 0."
 var left := empty list
 var right := empty list
 for each x with index i in m do
 if i &lt; (length of m)/2 then
 add x to left
 else
 add x to right
 // "Recursively sort both sublists."
 left := merge_sort(left)
 right := merge_sort(right)
 // Then merge the now-sorted sublists.
 return merge(left, right)
In this example, the function merges the left and right sublists.
 function merge(left, right) is
 var result := empty list
 while left is not empty and right is not empty do
 if first(left) ≤ first(right) then
 append first(left) to result
 left := rest(left)
 else
 append first(right) to result
 right := rest(right)
 // "Either left or right may have elements left; consume them."
 // "(Only one of the following loops will actually be entered.)"
 while left is not empty do
 append first(left) to result
 left := rest(left)
 while right is not empty do
 append first(right) to result
 right := rest(right)
 return result
Bottom-up implementation using lists.
Pseudocode for bottom-up merge sort algorithm which uses a small fixed size array of references to nodes, where array[i] is either a reference to a list of size 2"i" or "nil". "node" is a reference or pointer to a node. The merge() function would be similar to the one shown in the top-down merge lists example, it merges two already sorted lists, and handles empty lists. In this case, merge() would use "node" for its input parameters and return value.
 function merge_sort("node" head) is
 // return if empty list
 if head = nil then
 return nil
 var "node" array[32]; initially all nil
 var "node" result
 var "node" next
 var "int" i
 result := head
 // merge nodes into array
 while result ≠ nil do
 next := result.next;
 result.next := nil
 for (i = 0; (i &lt; 32) &amp;&amp; (array[i] ≠ nil); i += 1) do
 result := merge(array[i], result)
 array[i] := nil
 // do not go past end of array
 if i = 32 then
 i -= 1
 array[i] := result
 result := next
 // merge array into single list
 result := nil
 for (i = 0; i &lt; 32; i += 1) do
 result := merge(array[i], result)
 return result
Natural merge sort.
A natural merge sort is similar to a bottom-up merge sort except that any naturally occurring runs (sorted sequences) in the input are exploited. Both monotonic and bitonic (alternating up/down) runs may be exploited, with lists (or equivalently tapes or files) being convenient data structures (used as FIFO queues or LIFO stacks). In the bottom-up merge sort, the starting point assumes each run is one item long. In practice, random input data will have many short runs that just happen to be sorted. In the typical case, the natural merge sort may not need as many passes because there are fewer runs to merge. In the best case, the input is already sorted (i.e., is one run), so the natural merge sort need only make one pass through the data. In many practical cases, long natural runs are present, and for that reason natural merge sort is exploited as the key component of Timsort. Example:
 Start : 3 4 2 1 7 5 8 9 0 6
 Select runs : (3 4)(2)(1 7)(5 8 9)(0 6)
 Merge : (2 3 4)(1 5 7 8 9)(0 6)
 Merge : (1 2 3 4 5 7 8 9)(0 6)
 Merge : (0 1 2 3 4 5 6 7 8 9)
Formally, the natural merge sort is said to be Runs-optimal, where formula_1 is the number of runs in formula_2, minus one.
Tournament replacement selection sorts are used to gather the initial runs for external sorting algorithms.
Analysis.
In sorting "n" objects, merge sort has an average and worst-case performance of O("n" log "n"). If the running time of merge sort for a list of length "n" is "T"("n"), then the recurrence relation "T"("n") = 2"T"("n"/2) + "n" follows from the definition of the algorithm (apply the algorithm to two lists of half the size of the original list, and add the "n" steps taken to merge the resulting two lists). The closed form follows from the master theorem for divide-and-conquer recurrences.
The number of comparisons made by merge sort in the worst case is given by the sorting numbers. These numbers are equal to or slightly smaller than ("n" ⌈lg "n"⌉ − 2⌈lg "n"⌉ + 1), which is between ("n" lg "n" − "n" + 1) and ("n" lg "n" + "n" + O(lg "n")). Merge sort's best case takes about half as many iterations as its worst case.
For large "n" and a randomly ordered input list, merge sort's expected (average) number of comparisons approaches "α"·"n" fewer than the worst case, where formula_3
In the "worst" case, merge sort uses approximately 39% fewer comparisons than quicksort does in its "average" case, and in terms of moves, merge sort's worst case complexity is O("n" log "n") - the same complexity as quicksort's best case.
Merge sort is more efficient than quicksort for some types of lists if the data to be sorted can only be efficiently accessed sequentially, and is thus popular in languages such as Lisp, where sequentially accessed data structures are very common. Unlike some (efficient) implementations of quicksort, merge sort is a stable sort.
Merge sort's most common implementation does not sort in place; therefore, the memory size of the input must be allocated for the sorted output to be stored in (see below for variations that need only "n"/2 extra spaces).
Variants.
Variants of merge sort are primarily concerned with reducing the space complexity and the cost of copying.
A simple alternative for reducing the space overhead to "n"/2 is to maintain "left" and "right" as a combined structure, copy only the "left" part of "m" into temporary space, and to direct the "merge" routine to place the merged output into "m". With this version it is better to allocate the temporary space outside the "merge" routine, so that only one allocation is needed. The excessive copying mentioned previously is also mitigated, since the last pair of lines before the "return result" statement (function " merge "in the pseudo code above) become superfluous.
One drawback of merge sort, when implemented on arrays, is its working memory requirement. Several in-place variants have been suggested:
An alternative to reduce the copying into multiple lists is to associate a new field of information with each key (the elements in "m" are called keys). This field will be used to link the keys and any associated information together in a sorted list (a key and its related information is called a record). Then the merging of the sorted lists proceeds by changing the link values; no records need to be moved at all. A field which contains only a link will generally be smaller than an entire record so less space will also be used. This is a standard sorting technique, not restricted to merge sort.
Use with tape drives.
An external merge sort is practical to run using disk or tape drives when the data to be sorted is too large to fit into memory. External sorting explains how merge sort is implemented with disk drives. A typical tape drive sort uses four tape drives. All I/O is sequential (except for rewinds at the end of each pass). A minimal implementation can get by with just two record buffers and a few program variables.
Naming the four tape drives as A, B, C, D, with the original data on A, and using only two record buffers, the algorithm is similar to the bottom-up implementation, using pairs of tape drives instead of arrays in memory. The basic algorithm can be described as follows:
Instead of starting with very short runs, usually a hybrid algorithm is used, where the initial pass will read many records into memory, do an internal sort to create a long run, and then distribute those long runs onto the output set. The step avoids many early passes. For example, an internal sort of 1024 records will save nine passes. The internal sort is often large because it has such a benefit. In fact, there are techniques that can make the initial runs longer than the available internal memory. One of them, the Knuth's 'snowplow' (based on a binary min-heap), generates runs twice as long (on average) as a size of memory used.
With some overhead, the above algorithm can be modified to use three tapes. "O"("n" log "n") running time can also be achieved using two queues, or a stack and a queue, or three stacks. In the other direction, using "k" &gt; two tapes (and "O"("k") items in memory), we can reduce the number of tape operations in "O"(log "k") times by using a k/2-way merge.
A more sophisticated merge sort that optimizes tape (and disk) drive usage is the polyphase merge sort.
Optimizing merge sort.
On modern computers, locality of reference can be of paramount importance in software optimization, because multilevel memory hierarchies are used. Cache-aware versions of the merge sort algorithm, whose operations have been specifically chosen to minimize the movement of pages in and out of a machine's memory cache, have been proposed. For example, the algorithm stops partitioning subarrays when subarrays of size S are reached, where S is the number of data items fitting into a CPU's cache. Each of these subarrays is sorted with an in-place sorting algorithm such as insertion sort, to discourage memory swaps, and normal merge sort is then completed in the standard recursive fashion. This algorithm has demonstrated better performance on machines that benefit from cache optimization. 
 suggested an alternative version of merge sort that uses constant additional space. This algorithm was later refined. 
Also, many applications of external sorting use a form of merge sorting where the input get split up to a higher number of sublists, ideally to a number for which merging them still makes the currently processed set of pages fit into main memory.
Parallel merge sort.
Merge sort parallelizes well due to the use of the divide-and-conquer method. Several different parallel variants of the algorithm have been developed over the years. Some parallel merge sort algorithms are strongly related to the sequential top-down merge algorithm while others have a different general structure and use the K-way merge method.
Merge sort with parallel recursion.
The sequential merge sort procedure can be described in two phases, the divide phase and the merge phase. The first consists of many recursive calls that repeatedly perform the same division process until the subsequences are trivially sorted (containing one or no element). An intuitive approach is the parallelization of those recursive calls. Following pseudocode describes the merge sort with parallel recursion using the fork and join keywords:
 // "Sort elements lo through hi (exclusive) of array A."
 algorithm mergesort(A, lo, hi) is
 if lo+1 &lt; hi then // "Two or more elements."
 mid := ⌊(lo + hi) / 2⌋
 fork mergesort(A, lo, mid)
 mergesort(A, mid, hi)
 join
 merge(A, lo, mid, hi)
This algorithm is the trivial modification of the sequential version and does not parallelize well. Therefore, its speedup is not very impressive. It has a span of formula_4, which is only an improvement of formula_5 compared to the sequential version (see Introduction to Algorithms). This is mainly due to the sequential merge method, as it is the bottleneck of the parallel executions.
Merge sort with parallel merging.
Better parallelism can be achieved by using a parallel merge algorithm. Cormen et al. present a binary variant that merges two sorted sub-sequences into one sorted output sequence.
In one of the sequences (the longer one if unequal length), the element of the middle index is selected. Its position in the other sequence is determined in such a way that this sequence would remain sorted if this element were inserted at this position. Thus, one knows how many other elements from both sequences are smaller and the position of the selected element in the output sequence can be calculated. For the partial sequences of the smaller and larger elements created in this way, the merge algorithm is again executed in parallel until the base case of the recursion is reached.
The following pseudocode shows the modified parallel merge sort method using the parallel merge algorithm (adopted from Cormen et al.).
 * A: Input array
 * B: Output array
 * lo: lower bound
 * hi: upper bound
 * off: offset
 algorithm parallelMergesort(A, lo, hi, B, off) is
 len := hi - lo + 1
 if len == 1 then
 B[off] := A[lo]
 else let T[1..len] be a new array
 mid := ⌊(lo + hi) / 2⌋ 
 mid' := mid - lo + 1
 fork parallelMergesort(A, lo, mid, T, 1)
 parallelMergesort(A, mid + 1, hi, T, mid' + 1) 
 join 
 parallelMerge(T, 1, mid', mid' + 1, len, B, off)
In order to analyze a recurrence relation for the worst case span, the recursive calls of parallelMergesort have to be incorporated only once due to their parallel execution, obtaining
formula_6
For detailed information about the complexity of the parallel merge procedure, see Merge algorithm.
The solution of this recurrence is given by
formula_7
This parallel merge algorithm reaches a parallelism of formula_8, which is much higher than the parallelism of the previous algorithm. Such a sort can perform well in practice when combined with a fast stable sequential sort, such as insertion sort, and a fast sequential merge as a base case for merging small arrays.
Parallel multiway merge sort.
It seems arbitrary to restrict the merge sort algorithms to a binary merge method, since there are usually p &gt; 2 processors available. A better approach may be to use a K-way merge method, a generalization of binary merge, in which formula_9 sorted sequences are merged together. This merge variant is well suited to describe a sorting algorithm on a PRAM.
Basic Idea.
Given an unsorted sequence of formula_10 elements, the goal is to sort the sequence with formula_11 available processors. These elements are distributed equally among all processors and sorted locally using a sequential Sorting algorithm. Hence, the sequence consists of sorted sequences formula_12 of length formula_13. For simplification let formula_10 be a multiple of formula_11, so that formula_16 for formula_17.
These sequences will be used to perform a multisequence selection/splitter selection. For formula_18, the algorithm determines splitter elements formula_19 with global rank formula_20. Then the corresponding positions of formula_21 in each sequence formula_22 are determined with binary search and thus the formula_22 are further partitioned into formula_11 subsequences formula_25 with formula_26.
Furthermore, the elements of formula_27 are assigned to processor formula_28, means all elements between rank formula_29 and rank formula_30, which are distributed over all formula_22. Thus, each processor receives a sequence of sorted sequences. The fact that the rank formula_9 of the splitter elements formula_33 was chosen globally, provides two important properties: On the one hand, formula_9 was chosen so that each processor can still operate on formula_35 elements after assignment. The algorithm is perfectly load-balanced. On the other hand, all elements on processor formula_28 are less than or equal to all elements on processor formula_37. Hence, each processor performs the "p"-way merge locally and thus obtains a sorted sequence from its sub-sequences. Because of the second property, no further "p"-way-merge has to be performed, the results only have to be put together in the order of the processor number.
Multi-sequence selection.
In its simplest form, given formula_11 sorted sequences formula_12 distributed evenly on formula_11 processors and a rank formula_9, the task is to find an element formula_42 with a global rank formula_9 in the union of the sequences. Hence, this can be used to divide each formula_22 in two parts at a splitter index formula_45, where the lower part contains only elements which are smaller than formula_42, while the elements bigger than formula_42 are located in the upper part.
The presented sequential algorithm returns the indices of the splits in each sequence, e.g. the indices formula_45 in sequences formula_22 such that formula_50 has a global rank less than formula_9 and formula_52.
 algorithm msSelect(S : Array of sorted Sequences [S_1..,S_p], k : int) is
 for i = 1 to p do 
 (l_i, r_i) = (0, |S_i|-1)
 while there exists i: l_i &lt; r_i do
 // pick Pivot Element in S_j[l_j], .., S_j[r_j], chose random j uniformly
 v := pickPivot(S, l, r)
 for i = 1 to p do 
 m_i = binarySearch(v, S_i[l_i, r_i]) // sequentially
 if m_1 + ... + m_p &gt;= k then // m_1+ ... + m_p is the global rank of v
 r := m // vector assignment
 else
 l := m 
 return l
For the complexity analysis the PRAM model is chosen. If the data is evenly distributed over all formula_11, the p-fold execution of the "binarySearch" method has a running time of formula_54. The expected recursion depth is formula_55 as in the ordinary Quickselect. Thus the overall expected running time is formula_56.
Applied on the parallel multiway merge sort, this algorithm has to be invoked in parallel such that all splitter elements of rank formula_57 for formula_58 are found simultaneously. These splitter elements can then be used to partition each sequence in formula_11 parts, with the same total running time of formula_60.
Pseudocode.
Below, the complete pseudocode of the parallel multiway merge sort algorithm is given. We assume that there is a barrier synchronization before and after the multisequence selection such that every processor can determine the splitting elements and the sequence partition properly.
 * d: Unsorted Array of Elements
 * n: Number of Elements
 * p: Number of Processors
 * return Sorted Array
 algorithm parallelMultiwayMergesort(d : Array, n : int, p : int) is
 o := new Array[0, n] // the output array
 for i = 1 to p do in parallel // each processor in parallel
 S_i := d[(i-1) * n/p, i * n/p] // Sequence of length n/p
 sort(S_i) // sort locally
 synch
 v_i := msSelect([S_1...,S_p], i * n/p) // element with global rank i * n/p
 synch
 (S_i,1 ..., S_i,p) := sequence_partitioning(si, v_1, ..., v_p) // split s_i into subsequences
 o[(i-1) * n/p, i * n/p] := kWayMerge(s_1,i, ..., s_p,i) // merge and assign to output array
 return o
Analysis.
Firstly, each processor sorts the assigned formula_61 elements locally using a sorting algorithm with complexity formula_62. After that, the splitter elements have to be calculated in time formula_63. Finally, each group of formula_11 splits have to be merged in parallel by each processor with a running time of formula_65 using a sequential p-way merge algorithm. Thus, the overall running time is given by
formula_66.
Practical adaption and application.
The multiway merge sort algorithm is very scalable through its high parallelization capability, which allows the use of many processors. This makes the algorithm a viable candidate for sorting large amounts of data, such as those processed in computer clusters. Also, since in such systems memory is usually not a limiting resource, the disadvantage of space complexity of merge sort is negligible. However, other factors become important in such systems, which are not taken into account when modelling on a PRAM. Here, the following aspects need to be considered: Memory hierarchy, when the data does not fit into the processors cache, or the communication overhead of exchanging data between processors, which could become a bottleneck when the data can no longer be accessed via the shared memory.
Sanders et al. have presented in their paper a bulk synchronous parallel algorithm for multilevel multiway mergesort, which divides formula_11 processors into formula_68 groups of size formula_69. All processors sort locally first. Unlike single level multiway mergesort, these sequences are then partitioned into formula_68 parts and assigned to the appropriate processor groups. These steps are repeated recursively in those groups. This reduces communication and especially avoids problems with many small messages. The hierarchical structure of the underlying real network can be used to define the processor groups (e.g. racks, clusters...).
Further Variants.
Merge sort was one of the first sorting algorithms where optimal speed up was achieved, with Richard Cole using a clever subsampling algorithm to ensure "O"(1) merge. Other sophisticated parallel sorting algorithms can achieve the same or better time bounds with a lower constant. For example, in 1991 David Powers described a parallelized quicksort (and a related radix sort) that can operate in "O"(log "n") time on a CRCW parallel random-access machine (PRAM) with "n" processors by performing partitioning implicitly. Powers further shows that a pipelined version of Batcher's Bitonic Mergesort at "O"((log "n")2) time on a butterfly sorting network is in practice actually faster than his "O"(log "n") sorts on a PRAM, and he provides detailed discussion of the hidden overheads in comparison, radix and parallel sorting.
Comparison with other sort algorithms.
Although heapsort has the same time bounds as merge sort, it requires only Θ(1) auxiliary space instead of merge sort's Θ("n"). On typical modern architectures, efficient quicksort implementations generally outperform merge sort for sorting RAM-based arrays. On the other hand, merge sort is a stable sort and is more efficient at handling slow-to-access sequential media. Merge sort is often the best choice for sorting a linked list: in this situation it is relatively easy to implement a merge sort in such a way that it requires only Θ(1) extra space, and the slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.
As of Perl 5.8, merge sort is its default sorting algorithm (it was quicksort in previous versions of Perl). In Java, the Arrays.sort() methods use merge sort or a tuned quicksort depending on the datatypes and for implementation efficiency switch to insertion sort when fewer than seven array elements are being sorted. The Linux kernel uses merge sort for its linked lists. Python uses Timsort, another tuned hybrid of merge sort and insertion sort, that has become the standard sort algorithm in Java SE 7 (for arrays of non-primitive types), on the Android platform, and in GNU Octave.

