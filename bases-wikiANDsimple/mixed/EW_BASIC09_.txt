
BASIC09 is a structured BASIC programming language dialect developed by Microware on behalf of Motorola for the then-new Motorola 6809 CPU and released in February 1980. It is primarily used with the OS-9 operating system, released in 1979. Microware also released a version for OS-9/68k on the 68000 as Microware BASIC.
In contrast to typical BASICs of the era, BASIC09 includes a multi-pass compiler that produces compact bytecode known as I-code. I-code replaces a number of data structures found in other BASICs with direct pointers to code and values, speeding performance. Users can further compile code using the codice_1 command, at which point it can be called directly by OS-9 and operated as native code. In the case of PACKed code, a cut-down version of the BASIC09 runtime system is used, Runb, further improving memory footprint and load time.
The language includes a number of structured programming additions, including local variables, the ability to ignore line numbers in favor of named routines, user-defined structures, and several distinct base data types including 16-bit and 8-bit (byte) integers, in addition to floating point and strings.
Syntax.
Program organization.
A key difference between BASIC09 and conventional BASICs of the era, like the canonical Microsoft BASIC, is the addition of the codice_2/codice_3 structure which created separately executable blocks of code. Code in a codice_2 had more in common with complete programs in other BASICs, including the variables being local to the code, and their ability to be executed in a stand-alone fashion. codice_2s were called by name using the codice_6 command, and could include variables for function-call semantics; for instance, codice_7 calls a procedure named codice_8 that takes two parameters. Parameters were imported into the procedure using the codice_9 keyword, in this example codice_10:
 PROCEDURE add
 PARAMETER a,b
 PRINT a+b
 END
A side-effect of the use of named procedures is that the resulting memory workspace is, in effect, its own namespace. In this respect, the BASIC09 system appears to the user to be a directory of callable programs. This contrasts with typical BASICs, where only one program is available at a given time and the construction of larger programs calling library-like code generally requires the source code to be copied and pasted between separate programs. In BASIC09, the user can codice_11 procedures by name into the workspace and then call them from their own code to construct larger programs from the separately stored procedures.
In addition to code in the workspace, if the program invokes codice_6 with a procedure name that could not be found, it would then look for a disk file with the same name and load and run that file. This worked not only with BASIC09 code, but also any other executable program, including machine language files. This meant that BASIC09 could easily call system routines.
In addition to codice_6, other common BASIC commands likewise used names. For instance, codice_14 would print out the source code ("list") the procedure named "bob", while codice_15 prints out all of the procedures currently in memory. The prettyprinted output from codice_16 could be redirected to a file or a printer with a shell-like notation, e.g. codice_17. One could also codice_18 and codice_11 procedures from storage.
Structured programming.
In addition to the organizational properties of the codice_2, BASIC09 also included a number of extensions to the flow control statements found in BASIC to provide more structure. For instance, the codice_21 statement could be used in the traditional codice_21...codice_23 format on a single line, or it could be used in a structured multi-line format:
 IF x&gt;10 THEN
 PRINT "x is larger than 10"
 ELSE
 PRINT "x is smaller than 10"
 ENDIF
codice_24 loops naturally have a structured format as the codice_25 can be placed on any line, but BASIC09 also added codice_26 and codice_27 for additional clarity when working with non-indexed loops. It also included the center-exit codice_28 which used the codice_29 statement for testing anywhere in the loop's body.
Data types.
BASIC09 included several built-in data types. In addition to the traditional string (STRING) and 40-bit floating point (REAL) types found in most BASICs of the era, it also included the 16-bit signed INTEGER, the 8-bit unsigned BYTE, and the logical BOOLEAN type. The BOOLEAN types were not packed into bytes, a single BOOLEAN used an entire 8-bit byte to store a single value. The language provided separate bytewise boolean operators for bitwise operations on BYTEs and INTEGERs. In contrast to other BASICs that also operated different base types, BASIC09 did not "decorate" the variable name to indicate the type, and instead used the codice_30 for definitions; for instance, codice_31 to declare two BOOLEAN variables, or codice_32 for an array of five INTEGERs.
Additionally, BASIC09 included the codice_33 keyword, which allowed compound types to be defined, with each "element" listed on a single line separated by semicolons. For instance:
 TYPE employee_record=name:STRING;number(2):INTEGER;former:BOOLEAN
defines an employee record type named codice_34 with three elements, codice_35, codice_36 and codice_37. The employee_record type can now be used in a definition like any other type, for instance, codice_38, which defines an array of 100 employee_record's. The elements are accessed in code using dot notation, for instance, codice_39.
Runtime.
Editing.
Line numbers were used in most BASIC dialects primarily as a way to support the editor. Users would edit particular lines of code by typing a number, with the text following either adding to or replacing the lines already in memory. As every line of code had a number, this also made them suitable for indicating the target of a codice_40 or codice_41, compared to other languages like FORTRAN where a separate "line label" was used for this purpose.
BASIC09 did not normally use line numbers, so its editor had to be modified to allow the user to edit lines without referring to them by number. However, BASIC09 did not assume any sort of full-screen capability, so using cursor keys was not an option. Instead, the system had a separate editor prompt and allowed the user to move about using the and keys, moving forward or backward one line at a time. To insert a new line of code without a line number, the user left a blank at the start of the statement.
Note that the language is case sensitive for user-provided values like procedure and variable names, but not for keywords. Keywords typed into the editor in lower case will be shown in upper case when the program is codice_16ed. BASIC09 allowed multiple statements on a single line of code, but used the as a separator instead of the used in most dialects. This is because it used the colon in the codice_43 assignment operator, which was in addition to the normal codice_44. codice_43 was identical in effect to codice_44, but made the difference between assignments and comparisons more obvious.
Compiler.
The internal multipass compiler converts BASIC09 source code into a tokenized, optimized, bytecode, called I-code. I-code differs from the more traditional tokenizing approach found in most BASICs in that a number of items were placed directly in memory instead of using references that then had to be looked up.
For instance, in MS-based interpreters, a variable reference in code is left in string format; the variable codice_47 would be represented in memory by the three ASCII characters "VAL". During execution, when this variable is encountered in the code the interpreter has to look up that string in a table of variables, find the associated storage address in memory, and then finally read the value stored in that location. The table is usually constructed so that the value follows the name, to save time during the final lookup.
In contrast, in I-code the address of the variable is determined in advance and the reference in code is replaced by that address. This avoids a runtime search through the variable table. Other optimizations include a separate codice_24 routine used when the index variable is an INTEGER, and separate INTEGER and REAL math libraries.
For added performance, BASIC09 also included the codice_1 command which took a procedure name and returned an optimized version. Some of these optimizations included removing non-coding instructions like code comments and the replacement of constant expressions to a single value. For instance, codice_1 would recognize that codice_51 contains only constants on the right, and replaces it with the code codice_52, which requires only a single operation at runtime, the addition, removing the division and square root. codice_1 reduced the memory footprint of the procedure and improved performance by about 10 to 30%.
Lightweight runtime.
Although it was common to run programs within the BASIC09 environment, as it was in other BASICs, BASIC09 also shipped with a separate run-only version of the code known as Runb. Runb removed the editing and debugging features of the system, and was about half the size of the full BASIC09 as a result.
The purpose of Runb was primarily to run PACKed modules when called from other programs. This meant that if the user typed in the name of a BASIC09 module in the OS/9 command line, and that module has been marked as PACKed, it is opened and run by Runb instead of the BASIC09. This reduces memory footprint and improves load time.

