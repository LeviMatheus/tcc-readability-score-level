
UTF-16 (16-bit Unicode Transformation Format) is a character encoding capable of encoding all 1,112,064 non-surrogate code points of Unicode (in fact this number of code points is dictated by the design of UTF-16). The encoding is variable-length, as code points are encoded with one or two 16-bit "code units". UTF-16 arose from an earlier fixed-width 16-bit encoding known as UCS-2 (for 2-byte Universal Character Set) once it became clear that more than 216 (65,536) code points were needed.&lt;ref name="unicode.org/faq"&gt;&lt;/ref&gt;
UTF-16 is used internally by systems such as Microsoft Windows, the Java programming language and JavaScript/ECMAScript. It is also often used for plain text and for word-processing data files on Microsoft Windows. It is rarely used for files on Unix-like systems. As of May 2019, Windows also supports UTF-8 for 8-bit character based applications.
UTF-16 is the only web-encoding incompatible with ASCII, and never gained popularity on the web, where it is used by under 0.005% (less than 1 hundredth of 1 percent) of web pages. UTF-8, by comparison, is used by 97% of all web pages. The Web Hypertext Application Technology Working Group (WHATWG) considers UTF-8 "the mandatory encoding for all [text]" and that for security reasons browser applications should not use UTF-16.
History.
In the late 1980s, work began on developing a uniform encoding for a "Universal Character Set" (UCS) that would replace earlier language-specific encodings with one coordinated system. The goal was to include all required characters from most of the world's languages, as well as symbols from technical domains such as science, mathematics, and music. The original idea was to replace the typical 256-character encodings, which required 1 byte per character, with an encoding using 65,536 (216) values, which would require 2 bytes (16 bits) per character.
Two groups worked on this in parallel, ISO/IEC JTC 1/SC 2 and the Unicode Consortium, the latter representing mostly manufacturers of computing equipment. The two groups attempted to synchronize their character assignments so that the developing encodings would be mutually compatible. The early 2-byte encoding was originally called "Unicode", but is now called "UCS-2".
When it became increasingly clear that 216 characters would not suffice, IEEE introduced a larger 31-bit space and an encoding (UCS-4) that would require 4 bytes per character. This was resisted by the Unicode Consortium, both because 4 bytes per character wasted a lot of memory and disk space, and because some manufacturers were already heavily invested in 2-byte-per-character technology. The UTF-16 encoding scheme was developed as a compromise and introduced with version 2.0 of the Unicode standard in July 1996. It is fully specified in RFC 2781, published in 2000 by the IETF.
In the UTF-16 encoding, code points less than 216 are encoded with a single 16-bit code unit equal to the numerical value of the code point, as in the older UCS-2. The newer code points greater than or equal to 216 are encoded by a compound value using "two" 16-bit code units. These two 16-bit code units are chosen from the UTF-16 surrogate range which had not previously been assigned to characters. Values in this range are not used as characters, and UTF-16 provides no legal way to code them as individual code points. A UTF-16 stream, therefore, consists of single 16-bit code points outside the surrogate range for code points in the Basic Multilingual Plane (BMP), and pairs of 16-bit values within the surrogate range for code points above the BMP.
UTF-16 is specified in the latest versions of both the international standard ISO/IEC 10646 and the Unicode Standard. "UCS-2 should now be considered obsolete. It no longer refers to an encoding form in either 10646 or the Unicode Standard." There are no plans to extend UTF-16 to support a larger number of code points or the code points replaced by surrogates, as this would violate the Unicode Stability Policy with respect to general category or surrogate code points. (any scheme that remains a self-synchronizing code would require allocating at least one BMP code point to start a sequence. Changing the purpose of a code point is disallowed).
Description.
Each Unicode code point is encoded either as one or two 16-bit "code units". How these 16-bit codes are stored as bytes then depends on the 'endianness' of the text file or communication protocol.
A "character" may need from as few as two bytes to fourteen or even more bytes to be recorded. For instance an emoji flag character takes 8 bytes, since it is "constructed from a pair of Unicode scalar values" (and those vales are outside the BMP and require 4 bytes each).
U+0000 to U+D7FF and U+E000 to U+FFFF.
Both UTF-16 and UCS-2 encode code points in this range as single 16-bit code units that are numerically equal to the corresponding code points. These code points in the Basic Multilingual Plane (BMP) are the "only" code points that can be represented in UCS-2. As of Unicode 9.0, some modern non-Latin Asian, Middle-Eastern, and African scripts fall outside this range, as do most emoji characters.
Code points from U+010000 to U+10FFFF.
Code points from the other planes (called Supplementary Planes) are encoded as two 16-bit "code units" called a "surrogate pair", by the following scheme:
Illustrated visually, the distribution of "U"' between "W1" and "W2" looks like:
U' = yyyyyyyyyyxxxxxxxxxx // U - 0x10000
W1 = 110110yyyyyyyyyy // 0xD800 + yyyyyyyyyy
W2 = 110111xxxxxxxxxx // 0xDC00 + xxxxxxxxxx
The "high surrogate" and "low surrogate" are also known as "leading" and "trailing" surrogates, respectively, analogous to the leading and trailing bytes of UTF-8.
Since the ranges for the "high surrogates" (), "low surrogates" (), and valid BMP characters (0x0000‚Äì0xD7FF, 0xE000‚Äì0xFFFF) are disjoint, it is not possible for a surrogate to match a BMP character, or for two adjacent "code units" to look like a legal "surrogate pair". This simplifies searches a great deal. It also means that UTF-16 is "self-synchronizing" on 16-bit words: whether a code unit starts a character can be determined without examining earlier code units (i.e. the type of "code unit" can be determined by the ranges of values in which it falls). UTF-8 shares these advantages, but many earlier multi-byte encoding schemes (such as Shift JIS and other Asian multi-byte encodings) did not allow unambiguous searching and could only be synchronized by re-parsing from the start of the string (UTF-16 is not self-synchronizing if one byte is lost or if traversal starts at a random byte).
Because the most commonly used characters are all in the BMP, handling of surrogate pairs is often not thoroughly tested. This leads to persistent bugs and potential security holes, even in popular and well-reviewed application software (e.g. ).
The Supplementary Planes contain emoji, historic scripts, less used symbols, less used Chinese ideographs, etc. Since the encoding of Supplementary Planes contains 20 significant bits (10 of 16 bits in each of the "high" and "low surrogates"), 220 code points can be encoded, divided into 16 planes of 216 code points each. Including the separately-handled Basic Multilingual Plane, there are a total of 17 planes.
U+D800 to U+DFFF.
The Unicode standard permanently reserves these code point values for UTF-16 encoding of the high and low surrogates, and they will never be assigned a character, so there should be no reason to encode them. The official Unicode standard says that no UTF forms, including UTF-16, can encode these code points.
However, UCS-2, UTF-8, and UTF-32 can encode these code points in trivial and obvious ways, and a large amount of software does so, even though the standard states that such arrangements should be treated as encoding errors.
It is possible to unambiguously encode an "unpaired surrogate" (a high surrogate code point not followed by a low one, or a low one not preceded by a high one) in the format of UTF-16 by using a code unit equal to the code point. The result is not valid UTF-16, but the majority of UTF-16 encoder and decoder implementations do this then when translating between encodings. Windows allows unpaired surrogates in filenames and other places, which generally means they have to be supported by software in spite of their exclusion from the Unicode standard.
Examples.
To encode U+10437 (êê∑) to UTF-16:
To decode U+10437 (êê∑) from UTF-16:
The following table summarizes this conversion, as well as others. The colors indicate how bits from the code point are distributed among the UTF-16 bytes. Additional bits added by the UTF-16 encoding process are shown in black.
Byte-order encoding schemes.
UTF-16 and UCS-2 produce a sequence of 16-bit code units. Since most communication and storage protocols are defined for bytes, and each unit thus takes two 8-bit bytes, the order of the bytes may depend on the endianness (byte order) of the computer architecture.
To assist in recognizing the byte order of code units, UTF-16 allows a Byte Order Mark (BOM), a code point with the value U+FEFF, to precede the first actual coded value. (U+FEFF is the invisible zero-width non-breaking space/ZWNBSP character.) If the endian architecture of the decoder matches that of the encoder, the decoder detects the 0xFEFF value, but an opposite-endian decoder interprets the BOM as the non-character value U+FFFE reserved for this purpose. This incorrect result provides a hint to perform byte-swapping for the remaining values.
If the BOM is missing, RFC 2781 recommends that big-endian encoding be assumed. In practice, due to Windows using little-endian order by default, many applications assume little-endian encoding. It is also reliable to detect endianness by looking for null bytes, on the assumption that characters less than U+0100 are very common. If more even bytes (starting at 0) are null, then it is big-endian.
The standard also allows the byte order to be stated explicitly by specifying UTF-16BE or UTF-16LE as the encoding type. When the byte order is specified explicitly this way, a BOM is specifically "not" supposed to be prepended to the text, and a U+FEFF at the beginning should be handled as a ZWNBSP character. Most applications ignore a BOM in all cases despite this rule.
For Internet protocols, IANA has approved "UTF-16", "UTF-16BE", and "UTF-16LE" as the names for these encodings (the names are case insensitive). The aliases UTF_16 or UTF16 may be meaningful in some programming languages or software applications, but they are not standard names in Internet protocols.
Similar designations, UCS-2BE and UCS-2LE, are used to show versions of UCS-2.
Usage.
UTF-16 is used for text in the OS¬†API of all currently supported versions of Microsoft Windows (and including at least all since Windows CE/2000/XP/2003/Vista/7) including Windows 10. Since insider build 17035 and the April 2018 update, it has added UTF-8 support and as of May 2019 Microsoft recommends software use it instead of UTF-16. Older Windows NT systems (prior to Windows 2000) only support UCS-2. In Windows XP, no code point above U+FFFF is included in any font delivered with Windows for European languages. Files and network data tend to be a mix of UTF-16, UTF-8, and legacy byte encodings.
The IBM i operating system designates CCSID (code page) 13488 for UCS-2 encoding and CCSID 1200 for UTF-16 encoding, though the system treats them both as UTF-16.
UTF-16 is used by the Qualcomm BREW operating systems; the .NET environments; and the Qt cross-platform graphical widget toolkit.
Symbian OS used in Nokia S60 handsets and Sony Ericsson UIQ handsets uses UCS-2. iPhone handsets use UTF-16 for Short Message Service instead of UCS-2 described in the 3GPP TS 23.038 (GSM) and IS-637 (CDMA) standards.
The Joliet file system, used in CD-ROM media, encodes file names using UCS-2BE (up to sixty-four Unicode characters per file name).
The Python language environment officially only uses UCS-2 internally since version 2.0, but the UTF-8 decoder to "Unicode" produces correct UTF-16. Since Python 2.2, "wide" builds of Unicode are supported which use UTF-32 instead; these are primarily used on Linux. Python 3.3 no longer ever uses UTF-16, instead an encoding that gives the most compact representation for the given string is chosen from ASCII/Latin-1, UCS-2, and UTF-32.
Java originally used UCS-2, and added UTF-16 supplementary character support in J2SE 5.0.
JavaScript may use UCS-2 or UTF-16. As of ES2015, string methods and regular expression flags have been added to the language that permit handling strings from an encoding-agnostic perspective.
In many languages, quoted strings need a new syntax for quoting non-BMP characters, as the C-style codice_1 syntax explicitly limits itself to 4 hex digits. The following examples illustrate the syntax for the non-BMP character "ùÑû" (U+1D11E, MUSICAL SYMBOL G CLEF). The most common (used by C++, C#, D, and several other languages) is to use an upper-case 'U' with 8 hex digits such as codice_2. In Java 7 regular expressions, ICU, and Perl, the syntax codice_3 must be used; similarly, in ECMAScript 2015 (JavaScript), the escape format is codice_4. In many other cases (such as Java outside of regular expressions), the only way to get non-BMP characters is to enter the surrogate halves individually, for example: codice_5 for U+1D11E.
String implementations based on UTF-16 typically define lengths of the string and allow indexing in terms of these 16-bit "code units", not in terms of code points. Neither code points nor code units correspond to anything an end user might recognize as a ‚Äúcharacter‚Äù; the things users identify as characters may in general consist of a base code point and a sequence of combining characters (or might be a sequence of code points of some other kind, for example Hangul conjoining jamos) Unicode refers to this construct as a "grapheme cluster" and as such, applications dealing with Unicode strings, whatever the encoding, must cope with the fact that this limits their ability to arbitrarily split and combine strings.
UCS-2 is also supported by the PHP language and MySQL.
Swift, version 5, Apple's preferred application language, switched from UTF-16 to UTF-8 as the preferred encoding.

