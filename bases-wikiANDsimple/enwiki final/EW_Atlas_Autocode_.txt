
Atlas Autocode (AA) is a programming language developed around 1965 at the University of Manchester. A variant of the language ALGOL, it was developed by Tony Brooker and Derrick Morris for the Atlas computer. 
The word "Autocode" was basically an early term for "programming language". Different autocodes could vary greatly.
Features.
AA featured explicitly typed variables, subroutines, and functions. It omitted some ALGOL features such as "passing parameters by name", which in ALGOL 60 means passing the memory address of a short subroutine to recalculate a parameter each time it is mentioned.
The AA compiler generated range-checking for array accesses, and allowed an array to have dimensions that were determined at runtime, i.e., an array could be declared as codice_1, where codice_2 and codice_3 were calculated values.
AA high-level routines can include machine code, either to make an inner loop more efficient or to effect some operation which otherwise cannot be done easily.
AA includes a codice_4 data type to represent complex numbers, partly because of pressure from the electrical engineering department, as complex numbers are used to represent the behavior of alternating current. The imaginary unit square root of -1 was represented by codice_2, which was treated as a fixed complex constant = "i".
The codice_4 data type was dropped when Atlas Autocode later evolved into the language Edinburgh IMP. IMP was an extension of AA and was used to write the Edinburgh Multiple Access System (EMAS) operating system.
AA's second-greatest claim to fame (after being the progenitor of IMP and EMAS) was that it had many of the features of the original "Compiler Compiler". A variant of the AA compiler included run-time support for a top-down recursive descent parser. The style of parser used in the Compiler Compiler was in use continuously at Edinburgh from the 60's until almost the year 2000.
Other Autocodes were developed for the Titan computer, a prototype Atlas 2 at Cambridge, and the Ferranti Mercury.
Syntax.
Atlas Autocode's syntax was largely similar to ALGOL, though it was influenced by the output device which the author had available, a Friden Flexowriter. Thus, it allowed symbols like codice_7 for .5 and the superscript 2 for "to the power of 2". The Flexowriter supported overstriking and thus, AA did also: up to three characters could be overstruck as a single symbol. For example, the character set had no codice_8 symbol, so exponentiation was an overstrike of codice_9 and codice_10. The aforementioned underlining of reserved words (keywords) could also be done using overstriking. The language is described in detail in the Atlas Autocode Reference Manual.
Other Flexowriter characters that were found a use in AA were: codice_11 in floating-point numbers, "e.g.", codice_12 for modern codice_13 ; codice_14 to mean "the second half of a 48-bit Atlas memory word"; codice_15 for the mathematical constant pi.
When AA was ported to the English Electric KDF9 computer, the character set was changed to International Organization for Standardization (ISO) and that compiler has been recovered from an old paper tape by the Edinburgh Computer History Project and is available online, as is a high-quality scan of the original Edinburgh version of the Atlas Autocode manual.
Keywords in AA were distinguishable from other text by being underlined, which was implemented via overstrike in the Flexowriter (compare to bold in ALGOL). There were also two stropping regimes. First, there was an "uppercasedelimiters" mode where all uppercase letters (outside strings) were treated as underlined lowercase. Second, in some versions (but not in the original Atlas version), it was possible to strop keywords by placing a "codice_16" sign in front of them, for example the keyword codice_17 could be typed as codice_18 or codice_19. This significantly reduced typing, due to only needing one character, rather than overstriking the whole keyword. As in ALGOL, there were no reserved words in the language as keywords were identified by underlining (or stropping), not by recognising reserved character sequences. In the statement codice_20, there is both a keyword codice_21 and a variable named codice_21.
As in ALGOL, AA allowed spaces in variable names, such as codice_23. Spaces were not significant and were removed before parsing in a trivial pre-lexing stage called "line reconstruction". What the compiler would see in the above example would be "codice_24". Spaces were possible due partly to keywords being distinguished in other ways, and partly because the source was processed by scannerless parsing, without a separate lexing phase, which allowed the lexical syntax to be context-sensitive.
The syntax for expressions let the multiplication operator be omitted, e.g., codice_25 was treated as codice_26, and codice_27 was treated as codice_28 if codice_29 was not an array. In ambiguous uses, the longest possible name was taken (maximal munch), for example codice_30 was not treated as codice_31, whether or not codice_29 and codice_33 had been declared.
In the original Atlas Autocode for the Atlas computer, Atlas machine code instructions could be interpolated between the AA statements.

