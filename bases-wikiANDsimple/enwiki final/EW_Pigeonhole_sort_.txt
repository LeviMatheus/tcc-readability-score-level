
Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements ("n") and the length of the range of possible key values ("N") are approximately the same. It requires O("n" + "N") time. It is similar to counting sort, but differs in that it "moves items twice: once to the bucket array and again to the final destination [whereas] counting sort builds an auxiliary array then uses the array to compute each item's final destination and move the item there."
The pigeonhole algorithm works as follows:
Example.
Suppose one were sorting these value pairs by their first element:
For each value between 3 and 8 we set up a pigeonhole, then move each element to its pigeonhole:
The pigeonhole array is then iterated over in order, and the elements are moved back to the original list.
The difference between pigeonhole sort and counting sort is that in counting sort, the auxiliary array does not contain lists of input elements, only counts:
For arrays where "N" is much larger than "n", bucket sort is a generalization that is more efficient in space and time.
Python implementation.
from typing import List, Tuple, Any
def pigeonhole_sort(lst: List[Tuple[int, Any]]) -&gt; None:
 In-place sorts a list of (key, value) tuples by key.
 :param lst: A list of tuples, each having a key as a number and a value that can be anything.
 :return: None
 base = min(key for key, value in lst)
 size = max(key for key, value in lst) - base + 1
 # Create the empty list (of lists) to be filled
 # It's a list of lists because the key can appear twice
 pigeonholes: List[List[Tuple[int, Any]]] = [[] for _ in range(size)]
 for key, value in lst:
 index = key - base
 pigeonhole = pigeonholes[index]
 pigeonhole.append((key, value))
 lst = [] # Re-initialize the list: we're going to re-fill it from the pigeonholes 
 for pigeonhole in pigeonholes:
 lst.extend(pigeonhole)
References.
[[Category:Sorting algorithms]]
[[Category:Stable sorts]]
[[ru:Сортировка подсчётом#Алгоритм со списком]]

