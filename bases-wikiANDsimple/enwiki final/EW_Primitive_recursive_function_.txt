
In computability theory, a primitive recursive function is roughly speaking a function that can be computed by a computer program whose loops are all "for" loops (that is, an upper bound of the number of iterations of every loop can be determined before entering the loop). Primitive recursive functions form a strict subset of those general recursive functions that are also total functions. 
The importance of primitive recursive functions lies on the fact that most computable functions that are studied in number theory (and more generally in mathematics) are primitive recursive. For example, addition and division, the factorial and exponential function, and the function which returns the "n"th prime are all primitive recursive. In fact, for showing that a computable function is primitive recursive, it suffices to show that its computational complexity is bounded above by a primitive recursive function of the input size. It follows that it is difficult to devise a computable function that is "not" primitive recursive, although some are known (see below).
The set of primitive recursive functions is known as PR in computational complexity theory.
Definition.
The primitive recursive functions are among the number-theoretic functions, which are functions from the natural numbers (nonnegative integers) {0, 1, 2, ...} to the natural numbers. These functions take "n" arguments for some natural number "n" and are called "n"-ary.
The basic primitive recursive functions are given by these axioms:
More complex primitive recursive functions can be obtained by applying the operations given by these axioms:
Example. We take "f"("x") as the "S"("x") defined above. This f is a 1-ary primitive recursive function. And so is "g"("x") = "S"("x"). So "h"("x") defined as "f"("g"("x")) = "S"("S"("x")) is a primitive recursive 1-ary function too. Informally speaking, "h"("x") is the function that turns "x" into "x"+2.
Example. Suppose "f"("x") = "P"11("x") = "x" and "g"("x","y","z")= "S"("P"23("x","y","z")) = "S"("y"). Then "h"(0,"x") = "x" and "h"("S"("y"),"x") = "g"("y","h"("y","x"),"x") = "S"("h"("y","x")). Now "h"(0,1) = 1, "h"(1,1) = "S"("h"(0,1)) = 2, "h"(2,1) = "S"("h"(1,1)) = 3. This "h" is a 2-ary primitive recursive function. We can call it 'addition'.
Interpretation. The function "h" acts as a for loop from 0 up to the value of its first argument. The rest of the arguments for "h", denoted here with "x""i"’s ("i" = 1, ..., "k"), are a set of initial conditions for the For loop which may be used by it during calculations but which are immutable by it. The functions "f" and "g" on the right side of the equations which define "h" represent the body of the loop, which performs calculations. Function "f" is only used once to perform initial calculations. Calculations for subsequent steps of the loop are performed by "g". The first parameter of "g" is fed the “current” value of the For loop’s index. The second parameter of "g" is fed the result of the For loop’s previous calculations, from previous steps. The rest of the parameters for "g" are those immutable initial conditions for the For loop mentioned earlier. They may be used by "g" to perform calculations but they will not themselves be altered by "g".
The primitive recursive functions are the basic functions and those obtained from the basic functions by applying these operations a finite number of times.
Role of the projection functions.
The projection functions can be used to avoid the apparent rigidity in terms of the arity of the functions above; by using compositions with various projection functions, it is possible to pass a subset of the arguments of one function to another function. For example, if "g" and "h" are 2-ary primitive recursive functions then
is also primitive recursive. One formal definition using projection functions is
Converting predicates to numeric functions.
In some settings it is natural to consider primitive recursive functions that take as inputs tuples that mix numbers with truth values (that is "t" for true and "f" for false), or that produce truth values as outputs. This can be accomplished by identifying the truth values with numbers in any fixed manner. For example, it is common to identify the truth value "t" with the number 1 and the truth value "f" with the number 0. Once this identification has been made, the characteristic function of a set "A", which always returns 1 or 0, can be viewed as a predicate that tells whether a number is in the set "A". Such an identification of predicates with numeric functions will be assumed for the remainder of this article.
Computer language definition.
An example of a primitive recursive programming language is one that contains basic arithmetic operators (e.g. + and −, or ADD and SUBTRACT), conditionals and comparison (IF-THEN, EQUALS, LESS-THAN), and bounded loops, such as the basic for loop, where there is a known or calculable upper bound to all loops (FOR i FROM 1 TO n, with neither i nor n modifiable by the loop body). No control structures of greater generality, such as while loops or IF-THEN plus GOTO, are admitted in a primitive recursive language. Douglas Hofstadter's BlooP in "Gödel, Escher, Bach" is such a language. Adding unbounded loops (WHILE, GOTO) makes the language general recursive and Turing-complete, as are all real-world computer programming languages.
The definition of primitive recursive functions implies that their computation halts on every input (after a finite number of steps). On the other hand, the halting problem is indecidable for general recursive functions, even if they are total. That is, there are programs that halt on every input, but for which this can not be verified by an algorithm.
Examples.
Most number-theoretic functions definable using recursion on a single variable are primitive recursive. Basic examples include the addition and truncated subtraction functions.
Addition.
Intuitively, addition can be recursively defined with the rules:
To fit this into a strict primitive recursive definition, define:
Here S("n") is "the successor of "n"" (i.e., "n"+1), "P"11 is the identity function, and "P"23 is the projection function that takes 3 arguments and returns the second one. Functions "f" and "g" required by the above definition of the primitive recursion operation are respectively played by "P"11 and the composition of "S" and "P"23.
Subtraction.
Because primitive recursive functions use natural numbers rather than integers, and the natural numbers are not closed under subtraction, a truncated subtraction function (also called "proper subtraction") is studied in this context. This limited subtraction function sub("a", "b") [or "b" ∸ "a"] returns "b" - "a" if this is nonnegative and returns "0" otherwise.
The predecessor function acts as the opposite of the successor function and is recursively defined by the rules:
These rules can be converted into a more formal definition by primitive recursion:
The limited subtraction function is definable from the predecessor function in a manner analogous to the way addition is defined from successor:
Here sub("a", "b") corresponds to "b" ∸ "a"; for the sake of simplicity, the order of the arguments has been switched from the "standard" definition to fit the requirements of primitive recursion. This could easily be rectified using composition with suitable projections.
Other operations on natural numbers.
Exponentiation and primality testing are primitive recursive. Given primitive recursive functions "e", "f", "g", and "h", a function that returns the value of "g" when "e"≤"f" and the value of "h" otherwise is primitive recursive.
Operations on integers and rational numbers.
By using Gödel numberings, the primitive recursive functions can be extended to operate on other objects such as integers and rational numbers. If integers are encoded by Gödel numbers in a standard way, the arithmetic operations including addition, subtraction, and multiplication are all primitive recursive. Similarly, if the rationals are represented by Gödel numbers then the field operations are all primitive recursive.
Use in first-order Peano arithmetic.
In first-order Peano arithmetic, there are infinitely many variables (0-ary symbols) but no k-ary non-logical symbols with k&gt;0 other than S, +, *, and ≤. Thus in order to define primitive recursive functions one has to use the following trick by Gödel.
By using a Gödel numbering for sequences, for example Gödel's β function, any finite sequence of numbers can be encoded by a single number. Such a number can therefore represent the primitive recursive function until a given n.
Let "h" be a 1-ary primitive recursion function defined by:
where C is a constant and "g" is an already defined function.
Using Gödel's β function, for any sequence of natural numbers (k0, k1, …, kn), there are natural numbers b and c such that, for every i ≤ n, β(b, c, i) = ki. We may thus use the following formula to define "h"; more precisely, "m"="h"("n") is a shorthand for the following:
and the equating to "g", being already defined, is in fact shorthand for some other already defined formula (as is β, whose formula is given here).
The generalization to any k-ary primitive recursion function is trivial.
Relationship to recursive functions.
The broader class of partial recursive functions is defined by introducing an unbounded search operator. The use of this operator may result in a partial function, that is, a relation with "at most" one value for each argument, but does not necessarily have "any" value for any argument (see domain). An equivalent definition states that a partial recursive function is one that can be computed by a Turing machine. A total recursive function is a partial recursive function that is defined for every input.
Every primitive recursive function is total recursive, but not all total recursive functions are primitive recursive. The Ackermann function "A"("m","n") is a well-known example of a total recursive function (in fact, provable total), that is not primitive recursive. There is a characterization of the primitive recursive functions as a subset of the total recursive functions using the Ackermann function. This characterization states that a function is primitive recursive if and only if there is a natural number "m" such that the function can be computed by a Turing machine that always halts within A("m","n") or fewer steps, where "n" is the sum of the arguments of the primitive recursive function.
An important property of the primitive recursive functions is that they are a recursively enumerable subset of the set of all total recursive functions (which is not itself recursively enumerable). This means that there is a single computable function "f"("m","n") that enumerates the primitive recursive functions, namely:
"f" can be explicitly constructed by iteratively repeating all possible ways of creating primitive recursive functions. Thus, it is provably total. One can use a diagonalization argument to show that "f" is not recursive primitive in itself: had it been such, so would be "h"("n") = "f"("n","n")+1. But if this equals some primitive recursive function, there is an "m" such that "h"("n") = "f"("m","n") for all "n", and then "h"("m") = "f"("m","m"), leading to contradiction.
However, the set of primitive recursive functions is not the "largest" recursively enumerable subset of the set of all total recursive functions. For example, the set of provably total functions (in Peano arithmetic) is also recursively enumerable, as one can enumerate all the proofs of the theory. While all primitive recursive functions are provably total, the converse is not true.
Limitations.
Primitive recursive functions tend to correspond very closely with our intuition of what a computable function must be. Certainly the initial functions are intuitively computable (in their very simplicity), and the two operations by which one can create new primitive recursive functions are also very straightforward. However, the set of primitive recursive functions does not include every possible total computable function—this can be seen with a variant of Cantor's diagonal argument. This argument provides a total computable function that is not primitive recursive. A sketch of the proof is as follows:
This argument can be applied to any class of computable (total) functions that can be enumerated in this way, as explained in the article Machine that always halts. Note however that the "partial" computable functions (those that need not be defined for all arguments) can be explicitly enumerated, for instance by enumerating Turing machine encodings.
Other examples of total recursive but not primitive recursive functions are known:
Some common primitive recursive functions.
In the following we observe that primitive recursive functions can be of four types:
In the following the mark " ' ", e.g. a', is the primitive mark meaning "the successor of", usually thought of as " +1", e.g. a +1 =def a'. The functions 16-20 and #G are of particular interest with respect to converting primitive recursive predicates to, and extracting them from, their "arithmetical" form expressed as Gödel numbers.
Additional primitive recursive forms.
Some additional forms of recursion also define functions that are in fact
primitive recursive. Definitions in these forms may be easier to find or
more natural for reading or writing. Course-of-values recursion defines primitive recursive functions. Some forms of mutual recursion also define primitive recursive functions.
The functions that can be programmed in the LOOP programming language are exactly the primitive recursive functions. This gives a different characterization of the power of these functions. The main limitation of the LOOP language, compared to a Turing-complete language, is that in the LOOP language the number of times that each loop will run is specified before the loop begins to run.
Finitism and consistency results.
The primitive recursive functions are closely related to mathematical finitism, and are used in several contexts in mathematical logic where a particularly constructive system is desired. Primitive recursive arithmetic (PRA), a formal axiom system for the natural numbers and the primitive recursive functions on them, is often used for this purpose.
PRA is much weaker than Peano arithmetic, which is not a finitistic system. Nevertheless, many results in number theory and in proof theory can be proved in PRA. For example, Gödel's incompleteness theorem can be formalized into PRA, giving the following theorem:
Similarly, many of the syntactic results in proof theory can be proved in PRA, which implies that there are primitive recursive functions that carry out the corresponding syntactic transformations of proofs.
In proof theory and set theory, there is an interest in finitistic consistency proofs, that is, consistency proofs that themselves are finitistically acceptable. Such a proof establishes that the consistency of a theory "T" implies the consistency of a theory "S" by producing a primitive recursive function that can transform any proof of an inconsistency from "S" into a proof of an inconsistency from "T". One sufficient condition for a consistency proof to be finitistic is the ability to formalize it in PRA. For example, many consistency results in set theory that are obtained by forcing can be recast as syntactic proofs that can be formalized in PRA.
History.
Recursive definitions had been used more or less formally in mathematics before, but the construction of primitive recursion is traced back to Richard Dedekind's theorem 126 of his "Was sind und was sollen die Zahlen?" (1888). This work was the first to give a proof that a certain recursive construction defines a unique function.
Primitive recursive arithmetic was first proposed by Thoralf Skolem in 1923.
The current terminology was coined by Rózsa Péter (1934) after Ackermann had proved in 1928 that the function which today is named after him was not primitive recursive, an event which prompted the need to rename what until then were simply called recursive functions.

