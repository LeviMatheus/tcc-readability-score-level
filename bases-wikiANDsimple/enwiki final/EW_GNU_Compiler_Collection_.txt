
The GNU Compiler Collection (GCC) is an optimizing compiler produced by the GNU Project supporting various programming languages, hardware architectures and operating systems. The Free Software Foundation (FSF) distributes GCC as free software under the GNU General Public License (GNU GPL). GCC is a key component of the GNU toolchain and the standard compiler for most projects related to GNU and the Linux kernel. With roughly 15 million lines of code in 2019, GCC is one of the biggest open source programs in existence. It has played an important role in the growth of free software, as both a tool and an example.
When it was first released in 1987 by Richard Stallman, GCC 1.0 was named the GNU C Compiler since it only handled the C programming language. It was extended to compile C++ in December of that year. Front ends were later developed for Objective-C, Objective-C++, Fortran, Ada, D and Go, among others. The OpenMP and OpenACC specifications are also supported in the C and C++ compilers.
GCC has been ported to a wide variety of platforms and instruction set architectures, probably more than any other compiler, and is widely deployed as a tool in the development of both free and proprietary software. GCC is also available for many embedded systems, including ARM-based and Power ISA-based chips.
As well as being the official compiler of the GNU operating system, GCC has been adopted as the standard compiler by many other modern Unix-like computer operating systems, including most Linux distributions. Most BSD family operating systems also switched to GCC shortly after its release, although since then, FreeBSD, OpenBSD and Apple macOS have moved to the Clang compiler, largely due to political and licensing reasons. GCC can also compile code for Windows, Android, iOS, Solaris, HP-UX, AIX and DOS.
History.
In late 1983, in an effort to bootstrap the GNU operating system, Richard Stallman asked Andrew S. Tanenbaum, the author of the Amsterdam Compiler Kit (also known as the "Free University" "Compiler Kit") for permission to use that software for GNU. When Tanenbaum advised him that the compiler was not free, and that only the university was free, Stallman decided to work on a different compiler. His initial plan was to rewrite an existing compiler from Lawrence Livermore National Laboratory from Pastel to C with some help from Len Tower and others. Stallman wrote a new C front end for the Livermore compiler, but then realized that it required megabytes of stack space, an impossibility on a 68000 Unix system with only 64 KB, and concluded he would have to write a new compiler from scratch. None of the Pastel compiler code ended up in GCC, though Stallman did use the C front end he had written.
GCC was first released March 22, 1987, available by FTP from MIT. Stallman was listed as the author but cited others for their contributions, including Jack Davidson and Christopher Fraser for the idea of using RTL as an intermediate language, Paul Rubin for writing most of the preprocessor, and Leonard Tower for "parts of the parser, RTL generator, RTL definitions, and of the Vax machine description." Described as the "first free software hit" by Peter H. Salus, the GNU compiler arrived just at the time when Sun Microsystems was unbundling its development tools from its operating system, selling them separately at a higher combined price than the previous bundle, which led many of Sun's users to buy or download GCC instead of the vendor's tools. While Stallman considered GNU Emacs as his main project, by 1990, GCC supported thirteen computer architectures, was outperforming several vendor compilers, and was used commercially by several companies.
EGCS fork.
As GCC was licensed under the GPL, programmers wanting to work in other directions—particularly those writing interfaces for languages other than C—were free to develop their own fork of the compiler, provided they meet the GPL's terms, including its requirements to distribute source code. Multiple forks proved inefficient and unwieldy, however, and the difficulty in getting work accepted by the official GCC project was greatly frustrating for many, as the project favored stability over new features. The FSF kept such close control on what was added to the official version of GCC 2.x (developed since 1992) that GCC was used as one example of the "cathedral" development model in Eric S. Raymond's essay "The Cathedral and the Bazaar".
In 1997, a group of developers formed the "Experimental/Enhanced GNU Compiler System (EGCS)" to merge several experimental forks into a single project. The basis of the merger was a development snapshot of GCC (taken around the 2.7.2 and later followed up to 2.8.1 release). Mergers included g77 (Fortran), PGCC (P5 Pentium-optimized GCC), many C++ improvements, and many new architectures and operating system variants.
While both projects followed each others changes closely, EGCS development proved considerably more vigorous, so much so that the FSF officially halted development on their GCC 2.x compiler, blessed EGCS as the official version of GCC, and appointed the EGCS project as the GCC maintainers in April 1999. With the release of GCC 2.95 in July 1999 the two projects were once again united. GCC has since been maintained by a varied group of programmers from around the world under the direction of a steering committee.
GCC 3 (2002) removed a front-end for CHILL due to a lack of maintenance.
Before version 4.0 the Fortran front end was codice_1, which only supported FORTRAN 77, but later was dropped in favor of the new GNU Fortran front end that supports Fortran 95 and large parts of Fortran 2003 and Fortran 2008 as well.
As of version 4.8, GCC is implemented in C++.
Support for Cilk Plus existed from GCC 5 to GCC 7.
GCC has been ported to a wide variety of instruction set architectures, and is widely deployed as a tool in the development of both free and proprietary software. GCC is also available for many embedded systems, including Symbian (called "gcce"), ARM-based, and Power ISA-based chips. The compiler can target a wide variety of platforms, including video game consoles such as the PlayStation 2, Cell SPE of PlayStation 3, and Dreamcast. It has been ported to more kinds of processors and operating systems than any other compiler.
Supported languages.
, the recent 11.1 release of GCC includes front ends for C (codice_2), C++ (codice_3), Objective-C, Fortran (codice_4), Ada (GNAT), Go (codice_5) and D (GDC, since 9.1) programming languages, with the OpenMP and OpenACC parallel language extensions being supported since GCC 5.1. Versions prior to GCC 7 also supported Java (codice_6), allowing compilation of Java to native machine code. 
Regarding language version support for C++ and C, since GCC 11.1 the default target is "gnu++17", a superset of C++17, and "gnu11", a superset of C11, with strict standard support also available. GCC also provides experimental support for C++20 and upcoming C++23.
Third-party front ends exist for many languages, such as Pascal (codice_7), Modula-2, Modula-3, PL/I, and VHDL (codice_8). A few experimental branches exist to support additional languages, such as the GCC UPC compiler for Unified Parallel C or Rust.
Design.
GCC's external interface follows Unix conventions. Users invoke a language-specific driver program (codice_2 for C, codice_3 for C++, etc.), which interprets command arguments, calls the actual compiler, runs the assembler on the output, and then optionally runs the linker to produce a complete executable binary.
Each of the language compilers is a separate program that reads source code and outputs machine code. All have a common internal structure. A per-language front end parses the source code in that language and produces an abstract syntax tree ("tree" for short).
These are, if necessary, converted to the middle end's input representation, called "GENERIC" form; the middle end then gradually transforms the program towards its final form. Compiler optimizations and static code analysis techniques (such as FORTIFY_SOURCE, a compiler directive that attempts to discover some buffer overflows) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent RTL representation. Finally, machine code is produced using architecture-specific pattern matching originally based on an algorithm of Jack Davidson and Chris Fraser.
GCC was written primarily in C except for parts of the Ada front end. The distribution includes the standard libraries for Ada and C++ whose code is mostly written in those languages. On some platforms, the distribution also includes a low-level runtime library, libgcc, written in a combination of machine-independent C and processor-specific machine code, designed primarily to handle arithmetic operations that the target processor cannot perform directly.
GCC uses many standard tools in its build, including Perl, Flex, Bison, and other common tools. In addition, it currently requires three additional libraries to be present in order to build: GMP, MPC, and MPFR.
In May 2010, the GCC steering committee decided to allow use of a C++ compiler to compile GCC. The compiler was intended to be written mostly in C plus a subset of features from C++. In particular, this was decided so that GCC's developers could use the destructors and generics features of C++.
In August 2012, the GCC steering committee announced that GCC now uses C++ as its implementation language. This means that to build GCC from sources, a C++ compiler is required that understands ISO/IEC C++03 standard.
On May 18, 2020, GCC moved away from ISO/IEC C++03 standard to ISO/IEC C++11 standard (i.e. needed to compile, bootstrap, the compiler itself; by default it however compiles later versions of C++).
Front ends.
Each front end uses a parser to produce the abstract syntax tree of a given source file. Due to the syntax tree abstraction, source files of any of the different supported languages can be processed by the same back end. GCC started out using LALR parsers generated with Bison, but gradually switched to hand-written recursive-descent parsers for C++ in 2004, and for C and Objective-C in 2006. As of 2021 all front ends use hand-written recursive-descent parsers.
Until GCC 4.0 the tree representation of the program was not fully independent of the processor being targeted. The meaning of a tree was somewhat different for different language front ends, and front ends could provide their own tree codes. This was simplified with the introduction of GENERIC and GIMPLE, two new forms of language-independent trees that were introduced with the advent of GCC 4.0. GENERIC is more complex, based on the GCC 3.x Java front end's intermediate representation. GIMPLE is a simplified GENERIC, in which various constructs are "lowered" to multiple GIMPLE instructions. The C, C++, and Java front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC.
In either case, the so-called "gimplifier" then converts this more complex form into the simpler SSA-based GIMPLE form that is the common language for a large number of powerful language- and architecture-independent global (function scope) optimizations.
GENERIC and GIMPLE.
"GENERIC" is an intermediate representation language used as a "middle end" while compiling source code into executable binaries. A subset, called "GIMPLE", is targeted by all the front ends of GCC.
The middle stage of GCC does all of the code analysis and optimization, working independently of both the compiled language and the target architecture, starting from the GENERIC representation and expanding it to register transfer language (RTL). The GENERIC representation contains only the subset of the imperative programming constructs optimized by the middle end.
In transforming the source code to GIMPLE, complex expressions are split into a three-address code using temporary variables. This representation was inspired by the SIMPLE representation proposed in the McCAT compiler by Laurie J. Hendren for simplifying the analysis and optimization of imperative programs.
Optimization.
Optimization can occur during any phase of compilation; however, the bulk of optimizations are performed after the syntax and semantic analysis of the front end and before the code generation of the back end; thus a common, even though somewhat contradictory, name for this part of the compiler is the "middle end."
The exact set of GCC optimizations varies from release to release as it develops, but includes the standard algorithms, such as loop optimization, jump threading, common subexpression elimination, instruction scheduling, and so forth. The RTL optimizations are of less importance with the addition of global SSA-based optimizations on GIMPLE trees, as RTL optimizations have a much more limited scope, and have less high-level information.
Some of these optimizations performed at this level include dead code elimination, partial redundancy elimination, global value numbering, sparse conditional constant propagation, and scalar replacement of aggregates. Array dependence based optimizations such as automatic vectorization and automatic parallelization are also performed. Profile-guided optimization is also possible.
Back end.
The GCC's back end is partly specified by preprocessor macros and functions specific to a target architecture, for instance to define its endianness, word size, and calling conventions. The front part of the back end uses these to help decide RTL generation, so although GCC's RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have to comply with the machine description of the target architecture.
The machine description file contains RTL patterns, along with operand constraints, and code snippets to output the final assembly. The constraints indicate that a particular RTL pattern might only apply (for example) to certain hardware registers, or (for example) allow immediate operand offsets of only a limited size (e.g. 12, 16, 24, ... bit offsets, etc.). During RTL generation, the constraints for the given target architecture are checked. In order to issue a given snippet of RTL, it must match one (or more) of the RTL patterns in the machine description file, and satisfy the constraints for that pattern; otherwise, it would be impossible to convert the final RTL into machine code.
Towards the end of compilation, valid RTL is reduced to a "strict" form in which each instruction refers to real machine registers and a pattern from the target's machine description file. Forming strict RTL is a complicated task; an important step is register allocation, where real hardware registers are chosen to replace the initially assigned pseudo-registers. This is followed by a "reloading" phase; any pseudo-registers that were not assigned a real hardware register are 'spilled' to the stack, and RTL to perform this spilling is generated. Likewise, offsets that are too large to fit into an actual instruction must be broken up and replaced by RTL sequences that will obey the offset constraints.
In the final phase, the machine code is built by calling a small snippet of code, associated with each pattern, to generate the real instructions from the target's instruction set, using the final registers, offsets, and addresses chosen during the reload phase. The assembly-generation snippet may be just a string, in which case a simple string substitution of the registers, offsets, and/or addresses into the string is performed. The assembly-generation snippet may also be a short block of C code, performing some additional work, but ultimately returning a string containing the valid assembly code.
C++ Standard Library (libstdc++).
The GCC project includes an implementation of the C++ Standard Library called libstdc++, licensed under the GPLv3 License with an exception to link closed source application when sources are built with GCC.
The current version is 11.
Other features.
Some features of GCC include:
Architectures.
GCC target processor families as of version 4.3 include (note, GCC 8 and older versions are no longer supported):
As of GCC 11, a few more are supported (and e.g. SPU, i.e. Cell, dropped), e.g. Nvidia GPUs, i.e. Nvidia PTX intermediate code, and also AMD GCN code, 64-bit ARM (AArch64), not just 32-bit, RISC-V, MSP430, and eBPF (a non-Turing complete language running in the Linux kernel).
Lesser-known target processors supported in the standard release have included:
Additional processors have been supported by GCC versions maintained separately from the FSF version:
The GCJ Java compiler can target either a native machine language architecture or the Java virtual machine's Java bytecode. When retargeting GCC to a new platform, bootstrapping is often used. Motorola 68000, Zilog Z80, and other processors are also targeted in the GCC versions developed for various Texas Instruments, Hewlett Packard, Sharp, and Casio programmable graphing calculators.
License.
GCC is licensed under the GNU General Public License version 3. The "GCC runtime exception" permits compilation of proprietary programs (in addition to free software) with GCC. This does not impact the license terms of GCC source code.

