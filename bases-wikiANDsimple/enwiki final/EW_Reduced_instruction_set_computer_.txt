
A reduced instruction set computer, or RISC (), is a computer with a small, highly optimized set of instructions, rather than the more specialized set often found in other types of architecture, such as in a complex instruction set computer (CISC). The main distinguishing feature of RISC architecture is that the instruction set is optimized with a large number of registers and a highly regular instruction pipeline, allowing a low number of clock cycles per instruction (CPI). Core features of a RISC philosophy are a load/store architecture, in which memory is accessed through specific instructions rather than as a part of most instructions in the set, and requiring only single-cycle instructions.
Although a number of computers from the 1960s and 1970s have been identified as forerunners of RISCs, the modern concept dates to the 1980s. In particular, two projects at Stanford University and the University of California, Berkeley are most associated with the popularization of this concept. Stanford's MIPS would go on to be commercialized as the successful MIPS architecture, while Berkeley's RISC gave its name to the entire concept and was commercialized as the SPARC. Another success from this era was IBM's effort that eventually led to the IBM POWER instruction set architecture, PowerPC, and Power ISA. As these projects matured, a variety of similar designs flourished in the late 1980s and especially the early 1990s, representing a major force in the Unix workstation market as well as for embedded processors in laser printers, routers and similar products.
The many varieties of RISC designs include ARC, Alpha, Am29000, ARM, Atmel AVR, Blackfin, i860, i960, M88000, MIPS, PA-RISC, Power ISA (including PowerPC), RISC-V, SuperH, and SPARC. The use of ARM architecture processors in smartphones and tablet computers such as the iPad and Android devices provided a wide user base for RISC-based systems. RISC processors are also used in supercomputers, such as Fugaku, which, , is the world's fastest supercomputer.
History and development.
Alan Turing's 1946 Automatic Computing Engine (ACE) design had many of the characteristics of a RISC architecture. A number of systems, going back to the 1960s, have been credited as the first RISC architecture, partly based on their use of load/store approach. The term RISC was coined by David Patterson of the Berkeley RISC project, although somewhat similar concepts had appeared before.
The CDC 6600 designed by Seymour Cray in 1964 used a load/store architecture with only two addressing modes (register+register, and register+immediate constant) and 74 operation codes, with the basic clock cycle being 10 times faster than the memory access time. Partly due to the optimized load/store architecture of the CDC 6600, Jack Dongarra says that it can be considered a forerunner of modern RISC systems, although a number of other technical barriers needed to be overcome for the development of a modern RISC system.
IBM 801.
Michael J. Flynn views the first RISC system as the IBM 801 design, begun in 1975 by John Cocke and completed in 1980. The 801 developed out of an effort to build a 24-bit high-speed processor to use as the basis for a digital telephone switch. To reach their switching goal of 300 calls per second (1 million per hour) they calculated that the CPU required performance on the order of 12 MIPS, compared to their fastest mainframe machine of the time, the 370/168 which performed at 3.5 MIPS.
The design was based on a study of IBM's extensive collection of statistics on their existing platforms. These demonstrated that code in high-performance settings made extensive use of registers, and that they often ran out of them. This suggested that additional registers would further improve performance. Additionally, they noticed that compilers generally ignored the vast majority of the available instructions, especially orthogonal addressing modes. Instead, they selected the fastest version of any given instruction and then constructed small routines using it. This suggested that the majority of instructions could be removed without affecting the resulting code. These two conclusions worked in concert; removing instructions would allow the instruction codes to be shorter, freeing up bits in the instruction which could then be used to select among a larger set of registers.
The telephone switch program was canceled in 1975, but by then the team had demonstrated that the same design would offer significant performance gains running just about any code. In simulations, they showed that a compiler tuned to use registers wherever possible would run code about three times as fast as traditional designs. Somewhat surprisingly, the same code would run about 50% faster even on existing machines due to the improved register use. In practice, their experimental PL/8 compiler, a slightly cut-down version of PL/1, consistently produced code that ran much faster on their mainframes.
A 32-bit version of the 801 was eventually produced in a single-chip form as the IBM ROMP in 1981, which stood for 'Research OPD [Office Products Division] Micro Processor'. This CPU was designed for "mini" tasks, and was also used in the IBM RT PC in 1986, which turned out to be a commercial failure. But the 801 inspired several research projects, including new ones at IBM that would eventually lead to the IBM POWER instruction set architecture.
RISC and MIPS.
By the late 1970s, the 801 had become well-known in the industry. This coincided with new fabrication techniques that were allowing more complex chips to come to market. The Zilog Z80 of 1976 had 8,000 transistors, whereas the 1979 Motorola 68000 (68k) had 68,000. These newer designs generally used their newfound complexity to expand the instruction set to make it more orthogonal. Most, like the 68k, used microcode to do this, reading instructions and re-implementing them as a sequence of simpler internal instructions. In the 68k, a full of the transistors were used for this microcoding.
In 1979, David Patterson was sent on a sabbatical from University of California, Berkeley to help DEC's west-coast team improve the VAX microcode. Patterson was struck by the complexity of the coding process and concluded it was untenable. He first wrote a paper on ways to improve microcoding, but later changed his mind and decided microcode itself was the problem. With funding from the DARPA VLSI Program, Patterson started the Berkeley RISC effort. The Program, practically unknown today, led to a huge number of advances in chip design, fabrication, and even computer graphics. Considering a variety of programs from their BSD Unix variant, the Berkeley team found, as had IBM, that most programs made no use of the large variety of instructions in the 68k.
Patterson's early work pointed out an important problem with the traditional more-is-better approach; even those instructions that were critical to overall performance were being delayed by their trip through the microcode. If the microcode was removed, the programs would run faster. And since the microcode ultimately took a complex instruction and broke it into steps, there was no reason the compiler couldn't do this instead. These studies suggested that, even with no other changes, one could make a chip with fewer transistors that would run faster.
It was also discovered that, on microcoded implementations of certain architectures, complex operations tended to be "slower" than a sequence of simpler operations doing the same thing. This was in part an effect of the fact that many designs were rushed, with little time to optimize or tune every instruction; only those used most often were optimized, and a sequence of those instructions could be faster than a less-tuned instruction performing an equivalent operation as that sequence. One infamous example was the VAX's codice_1 instruction.
The Berkeley work also turned up a number of additional points. Among these was the fact that programs spent a significant amount of time performing subroutine calls and returns, and it seemed there was the potential to improve overall performance by speeding these calls. This led the Berkeley design to select a method known as register windows. They also noticed that the majority of mathematical instructions were simple assignments, only of them actually performed an operation like addition or subtraction. But when those operations did occur, they tended to be slow. This led to far more emphasis on the underlying data unit, as opposed to previous designs where the majority of the chip was dedicated to control.
The resulting Berkeley RISC was based on gaining performance through the use of pipelining and aggressive use of register windowing. In a traditional CPU, one has a small number of registers, and a program can use any register at any time. In a CPU with register windows, there are a huge number of registers, e.g., 128, but programs can only use a small number of them, e.g., eight, at any one time. A program that limits itself to eight registers per procedure can make very fast procedure calls: The call simply moves the window "down" by eight, to the set of eight registers used by that procedure, and the return moves the window back. The Berkeley RISC project delivered the RISC-I processor in 1982. Consisting of only 44,420 transistors (compared with averages of about 100,000 in newer CISC designs of the era) RISC-I had only 32 instructions, and yet completely outperformed any other single-chip design. They followed this up with the 40,760 transistor, 39 instruction RISC-II in 1983, which ran over three times as fast as RISC-I.
As the RISC project began to become known in Silicon Valley, a similar project began at Stanford University in 1981. This MIPS project grew out of a graduate course by John L. Hennessy, produced a functioning system in 1983, and could run simple programs by 1984. The MIPS approach emphasized an aggressive clock cycle and the use of the pipeline, making sure it could be run as "full" as possible. The MIPS system was followed by the MIPS-X and in 1984 Hennessy and his colleagues formed MIPS Computer Systems. The commercial venture resulted in a new architecture that was also called MIPS and the R2000 microprocessor in 1985.
The overall philosophy of the RISC concept was widely understood by the second half of the 1980s, and led the designers of the MIPS-X to put it this way in 1987:
Commercial breakout.
In the early 1980s, significant uncertainties surrounded the RISC concept. One concern involved the use of memory; a single instruction from a traditional processor like the 68k may be written out as perhaps a half dozen of the simpler RISC instructions. In theory, this could slow the system down as it spent more time fetching instructions from memory. But by the mid-1980s, the concepts had matured enough to be seen as commercially viable.
Commercial RISC designs began to emerge in the mid-1980s. The first MIPS R2000 appeared in January 1986, followed shortly thereafter by Hewlett Packard's PA-RISC in some of their computers. In the meantime, the Berkeley effort had become so well known that it eventually became the name for the entire concept. In 1987 Sun Microsystems began shipping systems with the SPARC processor, directly based on the Berkeley RISC II system. The US government Committee on Innovations in Computing and Communications credits the acceptance of the viability of the RISC concept to the success of the SPARC system. The success of SPARC renewed interest within IBM, which released new RISC systems by 1990 and by 1995 RISC processors were the foundation of a $15 billion server industry.
By the later 1980s, the new RISC designs were easily outperforming all traditional designs by a wide margin. At that point, all of the other vendors began RISC efforts of their own. Among these were the DEC Alpha, AMD Am29000, Intel i860 and i960, Motorola 88000, IBM POWER, and, slightly later, the IBM/Apple/Motorola PowerPC. Many of these have since disappeared due to them often offering no competitive advantage over others of the same era. Those that remain are often used only in niche markets or as parts of other systems, only SPARC and POWER have any significant remaining market. The outlier is the ARM, who, in partnership with Apple, developed a low-power design and then specialized in that market, which at the time was a niche. With the rise in mobile computing, especially after the introduction of the iPhone, ARM is now the most widely-used high-end CPU design in the market.
Competition between RISC and conventional CISC approaches was also the subject of theoretical analysis in the early 1980s, leading for example to the iron law of processor performance.
Since 2010 a new open source instruction set architecture (ISA), RISC-V, has been under development at the University of California, Berkeley, for research purposes and as a free alternative to proprietary ISAs. As of 2014, version 2 of the user space ISA is fixed. The ISA is designed to be extensible from a barebones core sufficient for a small embedded processor to supercomputer and cloud computing use with standard and chip designer defined extensions and coprocessors. It has been tested in silicon design with the ROCKET SoC which is also available as an open-source processor generator in the CHISEL language.
Characteristics and design philosophy.
Instruction set philosophy.
A common misunderstanding of the phrase "reduced instruction set computer" is that instructions are simply eliminated, resulting in a smaller set of instructions.
In fact, over the years, RISC instruction sets have grown in size, and today many of them have a larger set of instructions than many CISC CPUs. Some RISC processors such as the PowerPC have instruction sets as large as the CISC IBM System/370, for example; conversely, the DEC PDP-8—clearly a CISC CPU because many of its instructions involve multiple memory accesses—has only 8 basic instructions and a few extended instructions.
The term "reduced" in that phrase was intended to describe the fact that the amount of work any single instruction accomplishes is reduced—at most a single data memory cycle—compared to the "complex instructions" of CISC CPUs that may require dozens of data memory cycles in order to execute a single instruction.
The term load/store architecture is sometimes preferred.
Another way of looking at the RISC/CISC debate is to consider what is exposed to the compiler.
In a CISC processor, the hardware may internally use registers and flag bit in order to implement a single complex instruction such as STRING MOVE, but hide those details from the compiler.
The internal operations of a RISC processor are "exposed to the compiler", leading to the backronym 'Relegate Interesting Stuff to the Compiler'.
Instruction format.
Most RISC architectures have fixed-length instructions (commonly 32 bits) and a simple encoding, which simplifies fetch, decode, and issue logic considerably. One drawback of 32-bit instructions is reduced code density, which is more adverse a characteristic in embedded computing than it is in the workstation and server markets RISC architectures were originally designed to serve. To address this problem, several architectures, such as ARM, Power ISA, MIPS, RISC-V, and the Adapteva Epiphany, have an optional short, feature-reduced instruction format or instruction compression feature. The SH5 also follows this pattern, albeit having evolved in the opposite direction, having added longer media instructions to an original 16-bit encoding.
Hardware utilization.
For any given level of general performance, a RISC chip will typically have far fewer transistors dedicated to the core logic which originally allowed designers to increase the size of the register set and increase internal parallelism.
Other features of RISC architectures include:
RISC designs are also more likely to feature a Harvard memory model, where the instruction stream and the data stream are conceptually separated; this means that modifying the memory where code is held might not have any effect on the instructions executed by the processor (because the CPU has a separate instruction and data cache), at least until a special synchronization instruction is issued; CISC processors that have separate instruction and data caches generally keep them synchronized automatically, for backwards compatibility with older processors.
Many early RISC designs also shared the characteristic of having a branch delay slot, an instruction space immediately following a jump or branch. The instruction in this space is executed, whether or not the branch is taken (in other words the effect of the branch is delayed). This instruction keeps the ALU of the CPU busy for the extra time normally needed to perform a branch. Nowadays the branch delay slot is considered an unfortunate side effect of a particular strategy for implementing some RISC designs, and modern RISC designs generally do away with it (such as PowerPC and more recent versions of SPARC and MIPS).
Some aspects attributed to the first RISC-"labeled" designs around 1975 include the observations that the memory-restricted compilers of the time were often unable to take advantage of features intended to facilitate "manual" assembly coding, and that complex addressing modes take many cycles to perform due to the required additional memory accesses. It was argued that such functions would be better performed by sequences of simpler instructions if this could yield implementations small enough to leave room for many registers, reducing the number of slow memory accesses. In these simple designs, most instructions are of uniform length and similar structure, arithmetic operations are restricted to CPU registers and only separate "load" and "store" instructions access memory. These properties enable a better balancing of pipeline stages than before, making RISC pipelines significantly more efficient and allowing higher clock frequencies.
Yet another impetus of both RISC and other designs came from practical measurements on real-world programs. Andrew Tanenbaum summed up many of these, demonstrating that processors often had oversized immediates. For instance, he showed that 98% of all the constants in a program would fit in 13 bits, yet many CPU designs dedicated 16 or 32 bits to store them. This suggests that, to reduce the number of memory accesses, a fixed length machine could store constants in unused bits of the instruction word itself, so that they would be immediately ready when the CPU needs them (much like immediate addressing in a conventional design). This required small opcodes in order to leave room for a reasonably sized constant in a 32-bit instruction word.
Since many real-world programs spend most of their time executing simple operations, some researchers decided to focus on making those operations as fast as possible. The clock rate of a CPU is limited by the time it takes to execute the slowest "sub-operation" of any instruction; decreasing that cycle-time often accelerates the execution of other instructions. The focus on "reduced instructions" led to the resulting machine being called a "reduced instruction set computer" (RISC). The goal was to make instructions so simple that they could "easily" be pipelined, in order to achieve a "single clock" throughput at "high frequencies".
Later, it was noted that one of the most significant characteristics of RISC processors was that external memory was only accessible by a "load" or "store" instruction. All other instructions were limited to internal registers. This simplified many aspects of processor design: allowing instructions to be fixed-length, simplifying pipelines, and isolating the logic for dealing with the delay in completing a memory access (cache miss, etc.) to only two instructions. This led to RISC designs being referred to as "load/store" architectures.
Comparison to other architectures.
Some CPUs have been specifically designed to have a very small set of instructions – but these designs are very different from classic RISC designs, so they have been given other names such as minimal instruction set computer (MISC) or transport triggered architecture (TTA).
RISC architectures have traditionally had few successes in the desktop PC and commodity server markets, where the x86-based platforms remain the dominant processor architecture. However, this may change, as ARM-based processors are being developed for higher performance systems. Manufacturers including Cavium, AMD, and Qualcomm have released server processors based on the ARM architecture. ARM is further partnered with Cray in 2017 to produce an ARM-based supercomputer. On the desktop, Microsoft announced that it planned to support the PC version of Windows 10 on Qualcomm Snapdragon-based devices in 2017 as part of its partnership with Qualcomm. These devices will support Windows applications compiled for 32-bit x86 via an x86 processor emulator that translates 32-bit x86 code to ARM64 code. Apple announced they will transition their Mac desktop and laptop computers from Intel processors to internally developed ARM64-based SoCs called Apple silicon; the first such computers, using the Apple M1 processor, were released in November 2020. Macs with Apple silicon can run x86-64 binaries with Rosetta 2, an x86-64 to ARM64 translator.
Outside of the desktop arena, however, the ARM RISC architecture is in widespread use in smartphones, tablets and many forms of embedded device. While early RISC designs differed significantly from contemporary CISC designs, by 2000 the highest-performing CPUs in the RISC line were almost indistinguishable from the highest-performing CPUs in the CISC line.
Use of RISC architectures.
RISC architectures are now used across a range of platforms, from smartphones and tablet computers to some of the world's fastest supercomputers such as Fugaku, the fastest on the TOP500 list , and Summit, Sierra, and Sunway TaihuLight, the next three on that list.
Low-end and mobile systems.
By the beginning of the 21st century, the majority of low-end and mobile systems relied on RISC architectures. Examples include:



