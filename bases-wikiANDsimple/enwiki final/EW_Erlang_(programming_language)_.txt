
Erlang ( ) is a general-purpose, concurrent, functional programming language, and a garbage-collected runtime system. The term Erlang is used interchangeably with Erlang/OTP, or Open Telecom Platform (OTP), which consists of the Erlang runtime system, several ready-to-use components (OTP) mainly written in Erlang, and a set of design principles for Erlang programs.
The Erlang runtime system is designed for systems with these traits:
The Erlang programming language has immutable data, pattern matching, and functional programming. The sequential subset of the Erlang language supports eager evaluation, single assignment, and dynamic typing.
A normal Erlang application is built out of hundreds of small Erlang processes.
It was originally proprietary software within Ericsson, developed by Joe Armstrong, Robert Virding, and Mike Williams in 1986, but was released as free and open-source software in 1998. Erlang/OTP is supported and maintained by the Open Telecom Platform (OTP) product unit at Ericsson.
History.
The name "Erlang", attributed to Bjarne Däcker, has been presumed by those working on the telephony switches (for whom the language was designed) to be a reference to Danish mathematician and engineer Agner Krarup Erlang and a syllabic abbreviation of "Ericsson Language". Erlang was designed with the aim of improving the development of telephony applications. The initial version of Erlang was implemented in Prolog and was influenced by the programming language PLEX used in earlier Ericsson exchanges. By 1988 Erlang had proven that it was suitable for prototyping telephone exchanges, but the Prolog interpreter was far too slow. One group within Ericsson estimated that it would need to be 40 times faster to be suitable for production use. In 1992, work began on the BEAM virtual machine (VM) which compiles Erlang to C using a mix of natively compiled code and threaded code to strike a balance between performance and disk space. According to Armstrong, the language went from lab product to real applications following the collapse of the next-generation AXE telephone exchange named in 1995. As a result, Erlang was chosen for the next asynchronous transfer mode (ATM) exchange "AXD".
In 1998 Ericsson announced the AXD301 switch, containing over a million lines of Erlang and reported to achieve a high availability of nine "9"s. Shortly thereafter, Ericsson Radio Systems banned the in-house use of Erlang for new products, citing a preference for non-proprietary languages. The ban caused Armstrong and others to leave Ericsson. The implementation was open-sourced at the end of the year. Ericsson eventually lifted the ban and re-hired Armstrong in 2004.
In 2006, native symmetric multiprocessing support was added to the runtime system and VM.
Processes.
Erlang applications are built of very lightweight Erlang processes in the Erlang runtime system. Erlang processes can be seen as "living" objects (Object-oriented programming), with data encapsulation and message passing, but capable of changing behavior during runtime. The Erlang runtime system provides strict process isolation between Erlang processes (this includes data and garbage collection, separated individually by each Erlang process) and transparent communication between processes on different Erlang nodes (on different hosts).
Joe Armstrong, co-inventor of Erlang, summarized the principles of processes in his PhD thesis:
Joe Armstrong remarked in an interview with Rackspace in 2013: "If Java is 'write once, run anywhere', then Erlang is 'write once, run forever'.”
Usage.
In 2014, Ericsson reported Erlang was being used in its support nodes, and in GPRS, 3G and LTE mobile networks worldwide and also by Nortel and T-Mobile.
As Tim Bray, director of Web Technologies at Sun Microsystems, expressed in his keynote at O'Reilly Open Source Convention (OSCON) in July 2008:
Erlang is the programming language used to code WhatsApp.
Since being released as open source, Erlang has been spreading beyond Telecoms, establishing itself in other verticals such as FinTech, Gaming, Healthcare, Automotive, IoT and Blockchain. Apart from WhatsApp there are other companies listed as Erlang's success stories: Vocalink (a MasterCard company), Goldman Sachs, Nintendo, AdRoll, Grindr, BT Mobile, Samsung, OpenX, SITA.
Functional programming examples.
Factorial.
A factorial algorithm implemented in Erlang:
-module(fact). % This is the file 'fact.erl', the module and the filename must match
-export([fac/1]). % This exports the function 'fac' of arity 1 (1 parameter, no type, no name)
fac(0) -&gt; 1; % If 0, then return 1, otherwise (note the semicolon ; meaning 'else')
fac(N) when N &gt; 0, is_integer(N) -&gt; N * fac(N-1).
% Recursively determine, then return the result
% (note the period . meaning 'endif' or 'function end')
%% This function will crash if anything other than a nonnegative integer is given.
%% It illustrates the "Let it crash" philosophy of Erlang.
Fibonacci sequence.
A tail recursive algorithm that produces the Fibonacci sequence:
%% The module declaration must match the file name "series.erl" 
-module(series).
%% The export statement contains a list of all those functions that form
%% the module's public API. In this case, this module exposes a single
%% function called fib that takes 1 argument (I.E. has an arity of 1)
%% The general syntax for -export is a list containing the name and
%% arity of each public function
-export([fib/1]).
%% Public API
%% Handle cases in which fib/1 receives specific values
%% The order in which these function signatures are declared is a vital
%% part of this module's functionality
%% If fib/1 is passed precisely the integer 0, then return 0
fib(0) -&gt; 0;
%% If fib/1 receives a negative number, then return the atom err_neg_val
%% Normally, such defensive coding is discouraged due to Erlang's 'Let
%% it Crash' philosophy; however, in this case we should explicitly
%% prevent a situation that will crash Erlang's runtime engine
fib(N) when N &lt; 0 -&gt; err_neg_val;
%% If fib/1 is passed an integer less than 3, then return 1
%% The preceding two function signatures handle all cases where N &lt; 1,
%% so this function signature handles cases where N = 1 or N = 2
fib(N) when N &lt; 3 -&gt; 1;
%% For all other values, call the private function fib_int/3 to perform
%% the calculation
fib(N) -&gt; fib_int(N, 0, 1).
%% Private API
%% If fib_int/3 receives a 1 as its first argument, then we're done, so
%% return the value in argument B. Since we are not interested in the
%% value of the second argument, we denote this using _ to indicate a
%% "don't care" value
fib_int(1, _, B) -&gt; B;
%% For all other argument combinations, recursively call fib_int/3
%% where each call does the following:
%% - decrement counter N
%% - Take the previous fibonacci value in argument B and pass it as
%% argument A
%% - Calculate the value of the current fibonacci number and pass it
%% as argument B
fib_int(N, A, B) -&gt; fib_int(N-1, B, A+B).
Here's the same program without the explanatory comments:
-module(series).
-export([fib/1]).
fib(0) -&gt; 0;
fib(N) when N &lt; 0 -&gt; err_neg_val;
fib(N) when N &lt; 3 -&gt; 1;
fib(N) -&gt; fib_int(N, 0, 1).
fib_int(1, _, B) -&gt; B;
fib_int(N, A, B) -&gt; fib_int(N-1, B, A+B).
Quicksort.
Quicksort in Erlang, using list comprehension:
%% qsort:qsort(List)
%% Sort a list of items
-module(qsort). % This is the file 'qsort.erl'
-export([qsort/1]). % A function 'qsort' with 1 parameter is exported (no type, no name)
qsort([]) -&gt; []; % If the list [] is empty, return an empty list (nothing to sort)
qsort([Pivot|Rest]) -&gt;
 % Compose recursively a list with 'Front' for all elements that should be before 'Pivot'
 % then 'Pivot' then 'Back' for all elements that should be after 'Pivot'
 qsort([Front || Front &lt;- Rest, Front &lt; Pivot]) ++ 
 [Pivot] ++
 qsort([Back || Back &lt;- Rest, Back &gt;= Pivot]).
The above example recursively invokes the function codice_1 until nothing remains to be sorted. The expression codice_2 is a list comprehension, meaning "Construct a list of elements codice_3 such that codice_3 is a member of codice_5, and codice_3 is less than codice_7." codice_8 is the list concatenation operator.
A comparison function can be used for more complicated structures for the sake of readability.
The following code would sort lists according to length:
% This is file 'listsort.erl' (the compiler is made this way)
-module(listsort).
% Export 'by_length' with 1 parameter (don't care about the type and name)
-export([by_length/1]).
by_length(Lists) -&gt; % Use 'qsort/2' and provides an anonymous function as a parameter
 qsort(Lists, fun(A,B) -&gt; length(A) &lt; length(B) end).
qsort([], _)-&gt; []; % If list is empty, return an empty list (ignore the second parameter)
qsort([Pivot|Rest], Smaller) -&gt;
 % Partition list with 'Smaller' elements in front of 'Pivot' and not-'Smaller' elements
 % after 'Pivot' and sort the sublists.
 qsort([X || X &lt;- Rest, Smaller(X,Pivot)], Smaller)
 ++ [Pivot] ++
 qsort([Y || Y &lt;- Rest, not(Smaller(Y, Pivot))], Smaller).
A codice_7 is taken from the first parameter given to codice_10 and the rest of codice_11 is named codice_5. Note that the expression
[X || X &lt;- Rest, Smaller(X,Pivot)]
is no different in form from
[Front || Front &lt;- Rest, Front &lt; Pivot]
(in the previous example) except for the use of a comparison function in the last part, saying "Construct a list of elements codice_13 such that codice_13 is a member of codice_5, and codice_16 is true", with codice_16 being defined earlier as
fun(A,B) -&gt; length(A) &lt; length(B) end
The anonymous function is named codice_16 in the parameter list of the second definition of codice_1 so that it can be referenced by that name within that function. It is not named in the first definition of codice_1, which deals with the base case of an empty list and thus has no need of this function, let alone a name for it.
Data types.
Erlang has eight primitive data types:
And three compound data types:
Two forms of syntactic sugar are provided:
Erlang has no method to define classes, although there are external libraries available.
"Let it crash" coding style.
Erlang is designed with a mechanism that makes it easy for external processes to monitor for crashes (or hardware failures), rather than an in-process mechanism like exception handling used in many other programming languages. Crashes are reported like other messages, which is the only way processes can communicate with each other, and subprocesses can be spawned cheaply. The "let it crash" philosophy prefers that a process be completely restarted rather than trying to recover from a serious failure. Though it still requires handling of errors, this philosophy results in less code devoted to defensive programming where error-handling code is highly contextual and specific.
Supervisor trees.
A typical Erlang application is written in the form of a supervisor tree. This architecture is based on a hierarchy of processes in which the top level process is known as a "supervisor". The supervisor then spawns multiple child processes that act either as workers or more, lower level supervisors. Such hierarchies can exist to arbitrary depths and have proven to provide a highly scalable and fault-tolerant environment within which application functionality can be implemented.
Within a supervisor tree, all supervisor processes are responsible for managing the lifecycle of their child processes, and this includes handling situations in which those child processes crash. Any process can become a supervisor by first spawning a child process, then calling codice_35 on that process. If the monitored process then crashes, the supervisor will receive a message containing a tuple whose first member is the atom codice_36. The supervisor is responsible firstly for listening for such messages and secondly, for taking the appropriate action to correct the error condition.
Concurrency and distribution orientation.
Erlang's main strength is support for concurrency. It has a small but powerful set of primitives to create processes and communicate among them. Erlang is conceptually similar to the language occam, though it recasts the ideas of communicating sequential processes (CSP) in a functional framework and uses asynchronous message passing. Processes are the primary means to structure an Erlang application. They are neither operating system processes nor threads, but lightweight processes that are scheduled by BEAM. Like operating system processes (but unlike operating system threads), they share no state with each other. The estimated minimal overhead for each is 300 words. Thus, many processes can be created without degrading performance. In 2005, a benchmark with 20 million processes was successfully performed with 64-bit Erlang on a machine with 16 GB random-access memory (RAM; total 800 bytes/process). Erlang has supported symmetric multiprocessing since release R11B of May 2006.
While threads need external library support in most languages, Erlang provides language-level features to create and manage processes with the goal of simplifying concurrent programming. Though all concurrency is explicit in Erlang, processes communicate using message passing instead of shared variables, which removes the need for explicit locks (a locking scheme is still used internally by the VM).
Inter-process communication works via a shared-nothing asynchronous message passing system: every process has a "mailbox", a queue of messages that have been sent by other processes and not yet consumed. A process uses the codice_37 primitive to retrieve messages that match desired patterns. A message-handling routine tests messages in turn against each pattern, until one of them matches. When the message is consumed and removed from the mailbox the process resumes execution. A message may comprise any Erlang structure, including primitives (integers, floats, characters, atoms), tuples, lists, and functions.
The code example below shows the built-in support for distributed processes:
 % Create a process and invoke the function web:start_server(Port, MaxConnections)
 ServerProcess = spawn(web, start_server, [Port, MaxConnections]),
 % Create a remote process and invoke the function
 % web:start_server(Port, MaxConnections) on machine RemoteNode
 RemoteProcess = spawn(RemoteNode, web, start_server, [Port, MaxConnections]),
 % Send a message to ServerProcess (asynchronously). The message consists of a tuple
 % with the atom "pause" and the number "10".
 ServerProcess ! {pause, 10},
 % Receive messages sent to this process
 receive
 a_message -&gt; do_something;
 {data, DataContent} -&gt; handle(DataContent);
 {hello, Text} -&gt; io:format("Got hello message: ~s", [Text]);
 {goodbye, Text} -&gt; io:format("Got goodbye message: ~s", [Text])
 end.
As the example shows, processes may be created on remote nodes, and communication with them is transparent in the sense that communication with remote processes works exactly as communication with local processes.
Concurrency supports the primary method of error-handling in Erlang. When a process crashes, it neatly exits and sends a message to the controlling process which can then take action, such as starting a new process that takes over the old process's task.
Implementation.
The official reference implementation of Erlang uses BEAM. BEAM is included in the official distribution of Erlang, called Erlang/OTP. BEAM executes bytecode which is converted to threaded code at load time. It also includes a native code compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at Uppsala University. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system. It also supports interpreting, directly from source code via abstract syntax tree, via script as of R11B-5 release of Erlang.
Hot code loading and modules.
Erlang supports language-level Dynamic Software Updating. To implement this, code is loaded and managed as "module" units; the module is a compilation unit. The system can keep two versions of a module in memory at the same time, and processes can concurrently run code from each. The versions are referred to as the "new" and the "old" version. A process will not move into the new version until it makes an external call to its module.
An example of the mechanism of hot code loading:
 %% A process whose only job is to keep a counter.
 %% First version
 -module(counter).
 -export([start/0, codeswitch/1]).
 start() -&gt; loop(0).
 loop(Sum) -&gt;
 receive
 {increment, Count} -&gt;
 loop(Sum+Count);
 {counter, Pid} -&gt;
 Pid ! {counter, Sum},
 loop(Sum);
 code_switch -&gt;
 ?MODULE:codeswitch(Sum)
 % Force the use of 'codeswitch/1' from the latest MODULE version
 end.
 codeswitch(Sum) -&gt; loop(Sum).
For the second version, we add the possibility to reset the count to zero.
 %% Second version
 -module(counter).
 -export([start/0, codeswitch/1]).
 start() -&gt; loop(0).
 loop(Sum) -&gt;
 receive
 {increment, Count} -&gt;
 loop(Sum+Count);
 reset -&gt;
 loop(0);
 {counter, Pid} -&gt;
 Pid ! {counter, Sum},
 loop(Sum);
 code_switch -&gt;
 ?MODULE:codeswitch(Sum)
 end.
 codeswitch(Sum) -&gt; loop(Sum).
Only when receiving a message consisting of the atom codice_38 will the loop execute an external call to codeswitch/1 (codice_39 is a preprocessor macro for the current module). If there is a new version of the "counter" module in memory, then its codeswitch/1 function will be called. The practice of having a specific entry-point into a new version allows the programmer to transform state to what is needed in the newer version. In the example, the state is kept as an integer.
In practice, systems are built up using design principles from the Open Telecom Platform, which leads to more code upgradable designs. Successful hot code loading is exacting. Code must be written with care to make use of Erlang's facilities.
Distribution.
In 1998, Ericsson released Erlang as free and open-source software to ensure its independence from a single vendor and to increase awareness of the language. Erlang, together with libraries and the real-time distributed database Mnesia, forms the OTP collection of libraries. Ericsson and a few other companies support Erlang commercially.
Since the open source release, Erlang has been used by several firms worldwide, including Nortel and T-Mobile. Although Erlang was designed to fill a niche and has remained an obscure language for most of its existence, its popularity is growing due to demand for concurrent services.
Erlang has found some use in fielding massively multiplayer online role-playing game (MMORPG) servers.

