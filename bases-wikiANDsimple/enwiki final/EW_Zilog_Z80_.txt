
The Z80 is an 8-bit microprocessor introduced by Zilog as the startup company's first product. The Z80 was conceived by Federico Faggin in late 1974 and developed by him and his 11 employees starting in early 1975. The first working samples were delivered in March 1976, and it was officially introduced on the market in July 1976. With the revenue from the Z80, the company built its own chip factories and grew to over a thousand employees over the following two years.
The Zilog Z80 is a software-compatible extension and enhancement of the Intel 8080 and, like it, was mainly aimed at embedded systems. Although used in that role, the Z80 also became one of the most widely used CPUs in desktop computers and home computers from the 1970s to the mid-1980s. It was also common in military applications, musical equipment such as synthesizers (like the Roland Jupiter-8), and coin operated arcade games of the late 1970s and early 1980s including "Pac-Man".
Zilog licensed the Z80 to the US-based Synertek and Mostek, which had helped them with initial production, as well as to a European second source manufacturer, SGS. The design was also copied by several Japanese, East European and Soviet manufacturers. This won the Z80 acceptance in the world market since large companies like NEC, Toshiba, Sharp, and Hitachi started to manufacture the device (or their own Z80-compatible clones or designs).
In recent decades Zilog has refocused on the ever-growing market for embedded systems and the most recent Z80-compatible microcontroller family, the fully pipelined 24-bit eZ80 with a linear 16 MB address range, has been successfully introduced alongside the simpler Z80 and Z180 products.
History.
The Z80 came about when physicist and engineer Federico Faggin left Intel at the end of 1974 to found Zilog with . At Fairchild Semiconductor, and later at Intel, Faggin had been working on fundamental transistor and semiconductor manufacturing technology. He also developed the basic design methodology used for memories and microprocessors at Intel and led the work on the Intel 4004, the 8080 and several other ICs. Masatoshi Shima, the principal logic and transistor level-designer of the 4004 and the 8080 under Faggin's supervision, joined the Zilog team.
According to the designers, the primary targets for the Z80 CPU (and its optional support and peripheral ICs) were products like intelligent terminals, high end printers and advanced cash registers as well as telecom equipment, industrial robots and other kinds of automation equipment.
By March 1976, Zilog had developed the Z80 as well as an accompanying assembler based development system for its customers, and by July 1976, this was formally launched onto the market. Some of the Z80 support and peripheral ICs were under development at this point, and many of them were launched during the following year.
Early Z80s were manufactured by Synertek and Mostek, before Zilog had its own manufacturing factory ready, in late 1976. These companies were chosen because they could do the ion implantation needed to create the depletion-mode MOSFETs that the Z80 design used as load transistors in order to cope with a single 5 Volt power supply.
Faggin designed the instruction set to be binary compatible with the Intel 8080 so that most 8080 code, notably the CP/M operating system and Intel's PL/M compiler for 8080 (as well as its generated code), would run unmodified on the new Z80 CPU. Masatoshi Shima designed most of the microarchitecture as well as the gate and transistor levels of the Z80 CPU, assisted by a small number of engineers and layout people. CEO Federico Faggin was actually heavily involved in the chip layout work, together with two dedicated layout people. According to Faggin, he worked 80 hours a week in order to meet the tight schedule given by the financial investors.
The Z80 offered many improvements over the 8080:
The Z80 took over from the 8080 and its offspring, the 8085, in the processor market, and became one of the most popular 8-bit CPUs. Zilog was later by a few years than Intel (with its 80C85) to produce a low-power CMOS CPU, and this resulted in the Intel chip first appearing in use with battery-powered portable computers, such as Tandy/Radio Shack's TRS-80 Model 100 laptop from April 1983, which was designed and built by Kyocera and also sold by Kyocera, Olivetti, and NEC in various design variations under different names. In following years, however, the CMOS Z80 would dominate this market.
Some organizations, such as British Telecom, remained loyal to the 8085 for embedded applications owing to their familiarity with it, and to its on-chip support for a serial interface and multi-level interrupt architecture. Perhaps a key to the initial success of the Z80 was the built-in DRAM refresh, and other features which allowed systems to be built with fewer support chips (Z80 embedded systems typically use static RAM and hence do not need this refresh).
For the original NMOS design, the specified upper clock frequency limit increased successively from the introductory 2.5 MHz, via the well known 4 MHz (Z80A), up to 6 (Z80B) and 8 MHz (Z80H). The NMOS version has been produced as a 10 MHz part since the late 1980s. CMOS versions were developed with specified upper frequency limits ranging from 4 MHz up to 20 MHz for the version sold today. The CMOS versions allowed low-power standby with internal state retained, having no "lower" frequency limit. The fully compatible derivatives HD64180/Z180 and eZ80 are currently specified for up to 33 and 50 MHz respectively.
Design.
Programming model and register set.
The programming model and register set of the Z80 are fairly conventional, ultimately based on the register structure of the Datapoint 2200. The Z80 was designed as an extension of the Intel 8080, created by the same engineers, which in turn was an extension of the 8008. The 8008 was basically a PMOS implementation of the TTL-based CPU of the Datapoint 2200.
The 2200 design allowed 8-bit registers H and L (High and Low) to be paired into a 16-bit address register HL. In the 8080, this pairing was added to the BC and DE pairs as well, while HL was generalized to allow use as a 16-bit accumulator, not just an address register. The 8080 also introduced the important 8-bit immediate data mode for accumulator operations, and immediate 16-bit data for HL, BC and DE loads. Furthermore, direct 16-bit copying between HL and memory was now possible, using a direct address.
The Z80 orthogonalized this further by making all 16-bit register pairs, including IX and IY, more general purpose, as well as allowing 16-bit copying directly to and from memory for all of these pairs. The 16-bit IX and IY registers in the Z80 are primarily intended as base address-registers, where a particular instruction supplies a constant offset that is added to the previous values, but they are also usable as 16-bit accumulators, among other things. A limitation is that all operand references involving IX or IY require an extra instruction prefix byte, adding at least four clock cycles over the timing of an instruction using HL instead; this sometimes makes using IX or IY less efficient than a method using only the 8080-model registers. The Z80 also introduced a new signed overflow flag and complemented the fairly simple 16-bit arithmetics of the 8080 with dedicated instructions for "signed" 16-bit arithmetics.
The 8080-compatible registers AF, BC, DE, HL are duplicated as two separate banks in the Z80, where the processor can quickly switch from one bank to the other; a feature useful for speeding up responses to single-level, high-priority interrupts. A similar feature was present in the 2200, but was never implemented at Intel. The dual register-set is very useful in the embedded role, as it improves interrupt handling performance, but found widespread use in the personal computer role as an additional set of general registers for complex code like floating point arithmetics or home computer games.
Registers.
As on the 8080, 8-bit registers are typically paired to provide 16-bit versions. The 8080 compatible registers are:
The new registers introduced with the Z80 are:
There is no "direct" access to the alternate registers; instead, two special instructions, codice_15 and codice_16, each toggles one of two multiplexer flip-flops. This enables fast context switches for interrupt service routines: codice_17 may be used alone, for really simple and fast interrupt routines, or together with codice_16 to swap the whole BC, DE, HL set. This is still several times as fast as pushing the same registers on the stack. Slower, lower priority, or multi level interrupts normally use the stack to store registers, however.
The "refresh register", codice_10, increments each time the CPU fetches an opcode (or an opcode prefix, which internally executes like a 1-byte instruction) and has no simple relationship with program execution. This has sometimes been used to generate pseudorandom numbers in games, and also in software protection schemes. It has also been employed as a "hardware" counter in some designs; an example of this is the ZX81, which lets it keep track of character positions on the TV screen by triggering an interrupt at wrap around (by connecting INT to A6).
The "interrupt vector register", codice_9, is used for the Z80 specific mode 2 interrupts (selected by the codice_21 instruction). It supplies the high byte of the base address for a 128-entry table of service routine addresses which are selected via an index sent to the CPU during an interrupt acknowledge cycle; this index is simply the low byte part of the pointer to the tabulated indirect address pointing to the service routine. The pointer identifies a particular peripheral chip or peripheral function or event, where the chips are normally connected in a so-called daisy chain for priority resolution. Like the refresh register, this register has also sometimes been used creatively; in interrupt modes 0 and 1 (or in a system not using interrupts) it can be used as simply another 8-bit data register.
The instructions codice_22 and codice_23 affect the Z80 flags register, unlike all the other codice_24 (load) instructions. The Sign (bit 7) and Zero (bit 6) flags are set according to the data loaded from the Refresh or Interrupt source registers. For both instructions, the Parity/Overflow flag (bit 2) is set according to the current state of the IFF2 flip-flop.
Z80 assembly language.
Datapoint 2200 and Intel 8008.
The first Intel 8008 assembly language was based on a very simple (but systematic) syntax inherited from the Datapoint 2200 design. This original syntax was later transformed into a new, somewhat more traditional, assembly language form for this same original 8008 chip. At about the same time, the new assembly language was also extended to accommodate the added addressing possibilities in the more advanced Intel 8080 chip (the 8008 and 8080 shared a language subset without being binary compatible; however, the 8008 was binary compatible with the Datapoint 2200).
In this process, the mnemonic codice_25, for "LOAD", was replaced by various abbreviations of the words "LOAD", "STORE" and "MOVE", intermixed with other symbolic letters. The mnemonic letter codice_26, for "memory" (referenced by HL), was lifted out from within the instruction mnemonic to become a syntactically freestanding "operand", while registers and combinations of registers became very inconsistently denoted; either by abbreviated operands (MVI D, LXI H and so on), within the instruction mnemonic itself (LDA, LHLD and so on), or both at the same time (LDAX B, STAX D and so on).
"Illustration of four syntaxes, using samples of equivalent, or (for 8086) very similar, load and store instructions. The Z80 syntax uses parentheses around an expression to indicate that the value should be used as a memory address (as mentioned below), while the 8086 syntax uses brackets instead of ordinary parentheses for this purpose. Both Z80 and 8086 use the + sign to indicate that a constant is added to a base register to form an address"
New syntax.
Because Intel claimed a copyright on their assembly mnemonics, a new assembly syntax had to be developed for the Z80. This time a more systematic approach was used:
These principles made it straightforward to find names and forms for all new Z80 instructions, as well as orthogonalizations of old ones, such as codice_27.
Apart from naming differences, and despite a certain discrepancy in basic register structure, the Z80 and 8086 syntax are virtually isomorphic for a large portion of instructions. Only quite superficial similarities (such as the word MOV, or the letter X, for extended register) exist between the 8080 and 8086 assembly languages, although 8080 programs can be translated to 8086 assembly language by translator programs.
Instruction set and encoding.
The Z80 uses 252 out of the available 256 codes as single byte opcodes ("root instruction"); the four remaining codes are used extensively as opcode prefixes: CB and ED enable extra instructions, and DD or FD select IX+d or IY+d respectively (in some cases without displacement d) in place of HL. This scheme gives the Z80 a large number of permutations of instructions and registers; Zilog categorizes these into 158 different "instruction types", 78 of which are the same as those of the Intel 8080 (allowing operation of most 8080 programs on a Z80). The Zilog documentation further groups instructions into the following categories:
No multiply instructions are available in the original Z80. Different sizes and variants of additions, shifts, and rotates have somewhat differing effects on flags because most of the flag-changing properties of the 8080 were copied. However, the parity flag bit P of the 8080 (bit 2) is called P/V (parity/overflow) in the Z80 as it serves the additional purpose of a twos complement overflow indicator, a feature lacking in the 8080. Arithmetic instructions on the Z80 set it to indicate overflow rather than parity, while bitwise instructions still use it as a parity flag. (This introduces a subtle incompatibility of the Z80 with code written for the 8080, as the Z80 sometimes indicates signed overflow where the 8080 would indicate parity, possibly causing the logic of some practical 8080 software to fail on the Z80.) This new overflow flag is used for all new Z80-specific 16-bit operations (, ) as well as for 8-bit arithmetic operations, while the 16-bit operations inherited from the 8080 (, , ) do not affect it. Also, bit 1 of the flags register (a spare bit on the 8080) is used as a flag, N, that indicates whether the last arithmetic instruction executed was a subtraction or addition. The Z80 version of the instruction (Decimal Adjust Accumulator for BCD arithmetic) checks the N flag and behaves accordingly, so a (hypothetical) subtraction followed later by will yield a different result on an old 8080 than on the Z80. However, this would likely be erroneous code on the 8080, as was defined for addition only on that processor.
The Z80 has six new instructions that can load the DE, BC, and SP register pairs from memory, and load memory from these three register pairs—unlike the 8080. As on the 8080, load instructions do not affect the flags (except for the special purpose I and R register loads). A result of a regular encoding (common with the 8080) is that each of the 8-bit registers can be loaded from themselves (e.g. ). This is effectively a .
New block transfer instructions can move up to 64 kilobytes from memory to memory or between memory and I/O peripheral ports. Block instructions and (LoaD,Increment/Decrement,Repeat) use HL to point to the source address, DE to the destination address, and BC as a byte counter. Bytes are copied from source to destination, the pointers are incremented or decremented, and the byte counter is decremented until BC reaches zero. Non-repeating versions and move a single byte and bump the pointers and byte counter, which if it becomes zero resets the P/V flag. Corresponding memory-to-I/O instructions , , , , , , and operate similarly. The Z80 can input and output any register to an I/O port using register C to designate the port. (The 8080 only performs I/O through the accumulator A, using a direct port address specified in the instruction; a self-modifying code technique is required to use a variable 8080 port address.)
The last group of block instructions perform a compare operation between the byte at (HL) and the accumulator A. Register pair DE is not used. The repeating versions and only terminate if BC goes to zero or a match is found. HL is left pointing to the byte after () or before () the matching byte. If no match is found the Z flag is reset. There are non-repeating versions and .
Unlike the 8080, the Z80 can jump to a relative address ( instead of ) using a signed 8-bit displacement. Only the Zero and Carry flags can be tested for these new two-byte instructions. (All 8080 jumps and calls, conditional or not, are three-byte instructions.) A two-byte instruction specialized for program looping is also new to the Z80: (Decrement Jump if Non-Zero) takes a signed 8-bit displacement as an immediate operand. The B register is decremented, and if the result is nonzero then program execution jumps relative to PC; the flags remain unaltered. To perform an equivalent loop on an 8080 requires separate rement and conditional jump (to a two-byte absolute address) instructions (totalling four bytes), and the alters the flag register.
The index register (IX/IY, often abbreviated XY) instructions can be useful for accessing data organised in fixed heterogenous structures (such as records) or at fixed offsets relative a variable base address (as in recursive stack frames) and can also reduce code size by removing the need for multiple short instructions using non-indexed registers. However, although they may save speed in some contexts when compared to long/complex "equivalent" sequences of simpler operations, they incur a lot of additional CPU time ("e.g." 19 T-states to access one indexed memory location "vs." as little as 11 to access the same memory using HL and to point to the next). Thus, for simple or linear accesses of data, use of IX and IY tend to be slower and occupy more memory. Still, they may be useful in cases where the 'main' registers are all occupied, by removing the need to save/restore registers. Their officially undocumented 8-bit halves (see below) can be especially useful in this context, for they incur less slowdown than their 16-bit parents. Similarly, instructions for 16-bit additions are not particularly fast (11 clocks) in the original Z80 (being 1 clock slower than in the 8080/8085); nonetheless, they are about twice as fast as performing the same calculations using 8-bit operations, and equally important, they reduce register usage. It was not uncommon for programmers to "poke" different offset displacement bytes (which were typically calculated dynamically) into indexed instructions; this is an example of self-modifying code which was regular practice on nearly all early 8-bit processors with non-pipelined execution units.
The index registers have a parallel instruction to , which is . This is often seen in stack-oriented languages like Forth which at the end of every Forth word (atomic subroutines comprising the language) must jump unconditionally back to their thread interpreter routines. Typically this jump instruction appears many hundreds of times in an application, and using rather than saves a byte and two t-states each occurrence. This naturally makes the index register unavailable for any other use, or else the need to constantly reload it would negate its efficiency.
The 10-year-newer microcoded Z180 design could initially afford more "chip area", permitting a slightly more efficient implementation (using a wider ALU, among other things); similar things can be said for the Z800, Z280, and Z380. However, it was not until the fully pipelined eZ80 was launched in 2001 that those instructions finally became approximately as cycle-efficient as it is technically possible to make them, i.e. given the Z80 encodings combined with the capability to do an 8-bit read or write every clock cycle.
Undocumented instructions.
The index registers, IX and IY, were intended as flexible 16 bit pointers, enhancing the ability to manipulate memory, stack frames and data structures. Officially, they were treated as 16-bit only. In reality they were implemented as a pair of 8-bit registers, in the same fashion as the HL register, which is accessible either as 16 bits or separately as the "H"igh and "L"ow registers. The binary opcodes (machine language) were identical, but preceded by a new opcode prefix. Zilog published the opcodes and related mnemonics for the intended functions, but did not document the fact that every opcode that allowed manipulation of the H and L registers was equally valid for the 8 bit portions of the IX and IY registers. For example, the opcode 26h followed by an immediate byte value will load that value into the H register. Preceding this two-byte instruction with the IX register's opcode prefix, DD, would instead result in the most significant 8 bits of the IX register being loaded with that same value. A notable exception to this would be instructions similar to which make use of both the HL and IX or IY registers in the same instruction; in this case the DD prefix is only applied to the (IX+d) portion of the instruction. The halves of the XY registers could also hold operands for 8-bit arithmetic, logical and compare instructions, sparing the regular 8-bit registers for other use. The undocumented ability to increment and decrement the upper half of an index register made it easy to expand the range of the normal indexed instructions, without having to resort to the legal or .
There are several other undocumented instructions as well. Undocumented or illegal opcodes are not detected by the Z80 and have various effects, some of which are useful. However, as they are not part of the formal definition of the instruction set, different implementations of the Z80 are not guaranteed (or especially likely) to work the same way for every undocumented opcode.
Bugs.
The instruction does not conform to the Z80 documentation. Both the and instructions are supposed to leave the carry (C) flag unmodified. The instruction operates correctly; however, during the execution of the instruction, the carry flag takes the results of a spurious compare between the accumulator (A) and the last output of the instruction.
Example code.
The following Z80 assembly language source code is for a subroutine named codice_28 that copies a block of data bytes of a given size from one location to another. Important: the example code does not handle the case where the destination block overlaps the source; a serious limitation, but one that is irrelevant for some applications--such as, especially, when the source is in ROM and the destination in RAM, so they can never overlap. The sample code is extremely inefficient, intended to illustrate various instruction types, rather than best practices for speed. The data block is copied one byte at a time, and the data movement and looping logic utilizes 16-bit operations. Furthermore, the Z80 has a single instruction that will execute the entire loop (codice_29). Note that the assembled code is binary-compatible with the Intel 8080 and 8085 CPUs.
Instruction execution.
Each instruction is executed in steps that are usually termed machine cycles (M-cycles), each of which can take between three and six clock periods (T-cycles). Each M-cycle corresponds roughly to one memory access or internal operation. Many instructions actually end during the M1 of the "next" instruction which is known as a "fetch/execute overlap".
The Z80 machine cycles are sequenced by an internal state machine which builds each M-cycle out of 3, 4, 5 or 6 T-cycles depending on context. This avoids cumbersome asynchronous logic and makes the control signals behave consistently at a wide range of clock frequencies. It also means that a higher frequency crystal must be used than without this subdivision of machine cycles (approximately 2–3 times higher). It does not imply tighter requirements on memory access times, since a high resolution clock allows more precise control of memory timings and so memory can be active in parallel with the CPU to a greater extent, allowing more efficient use of available memory bandwidth.
One central example of this is that, for opcode fetch, the Z80 combines two full clock cycles into a memory access period (the M1-signal). In the Z80 this signal lasts for a relatively larger part of the typical instruction execution time than in a design such as the 6800, 6502, or similar, where this period would typically last typically 30-40% of a clock cycle. With memory chip affordability (i.e. access times around 450-250 ns in the 1980s) typically determining the fastest possible access time, this meant that such designs were locked to a significantly longer clock cycle (i.e. lower internal clock speed) than the Z80.
Memory was generally slow compared to the state machine sub-cycles (clock cycles) used in contemporary microprocessors. The shortest machine cycle that could safely be used in embedded designs has therefore often been limited by memory access times, not by the maximum CPU frequency (especially so during the home computer era). However, this relation has slowly changed during the last decades, particularly regarding SRAM; cacheless, single-cycle designs such as the eZ80 have therefore become much more meaningful recently.
The content of the refresh register R is sent out on the lower half of the address bus along with a refresh control signal while the CPU is decoding and executing the fetched instruction. During refresh the contents of the Interrupt register I are sent out on the upper half of the address bus.
Compatible peripherals.
Zilog introduced a number of peripheral parts for the Z80, which all support the Z80's interrupt handling system and I/O address space. These include the Counter/Timer Channel (CTC), the SIO (Serial Input Output), the DMA (Direct Memory Access), the PIO (Parallel Input-Output) and the DART (Dual Asynchronous Receiver Transmitter). As the product line developed, low-power, high-speed and CMOS versions of these chips were introduced.
Like the 8080, 8085 and 8086 processors, but unlike processors such as the Motorola 6800 and MOS Technology 6502, the Z80 and 8080 has a separate control line and address space for I/O instructions. While some Z80-based computers such as the Osborne 1 used "Motorola-style" memory mapped input/output devices, usually the I/O space was used to address one of the many Zilog peripheral chips compatible with the Z80. Zilog I/O chips supported the Z80's new mode 2 interrupts which simplified interrupt handling for large numbers of peripherals.
The Z80 was officially described as supporting 16-bit (64 KB) memory addressing, and 8-bit (256 ports) I/O-addressing. All I/O instructions actually assert the entire 16-bit address bus. OUT (C),reg and IN reg,(C) places the contents of the entire 16 bit BC register on the address bus; OUT (n),A and IN A,(n) places the contents of the A register on b8-b15 of the address bus and n on b0-b7 of the address bus. A designer could choose to decode the entire 16 bit address bus on I/O operations in order to take advantage of this feature, or use the high half of the address bus to select subfeatures of the I/O device. This feature has also been used to minimise decoding hardware requirements, such as in the Amstrad CPC/PCW and ZX81.
Second sources and derivatives.
Second sources.
Mostek, who produced the first Z80 for Zilog, offered it as second-source as MK3880. SGS-Thomson (now STMicroelectronics) was a second-source, too, with their Z8400. Sharp and NEC developed second sources for the NMOS Z80, the LH0080 and μPD780C, respectively. The LH0080 was used in various home computers and personal computers made by Sharp and other Japanese manufacturers, including Sony MSX computers, and a number of computers in the Sharp MZ series.
Toshiba made a CMOS-version, the TMPZ84C00, which is believed (but not verified) to be the same design also used by Zilog for its own CMOS Z84C00. There were also Z80-chips made by GoldStar (now LG) and the BU18400 series of Z80-clones (including DMA, PIO, CTC, DART and SIO) in NMOS and CMOS made by ROHM Electronics.
In East Germany, an unlicensed clone of the Z80, known as the U880, was manufactured. It was very popular and was used in Robotron's and VEB Mikroelektronik Mühlhausen's computer systems (such as the KC85-series) and also in many self-made computer systems. In Romania another unlicensed clone could be found, named MMN80CPU and produced by Microelectronica, used in home computers like TIM-S, HC, COBRA.
Also, several clones of Z80 were created in the Soviet Union, notable ones being the T34BM1, also called КР1858ВМ1 (parallelling the Soviet 8080-clone KR580VM80A). The first marking was used in pre-production series, while the second had to be used for a larger production. Though, due to the collapse of Soviet microelectronics in the late 1980s, there are many more T34BM1s than КР1858ВМ1s.
Notable uses.
Desktop computers.
During the late 1970s and early 1980s, the Z80 was used in a great number of fairly anonymous business-oriented machines with the CP/M operating system, a combination that dominated the market at the time. Four well-known examples of Z80 business computers running CP/M are the Heathkit H89, the portable Osborne 1, the Kaypro series, and the Epson QX-10. Less well-known was the expensive high-end Otrona Attache. Some systems used multi-tasking operating system software (like MP/M or Morrow's Micronix) to share the one processor between several concurrent users.
Multiple home computers were introduced that used the Z80 as the main processor or as a plug-in option to allow access to software written for the Z80. Notable are the TRS-80 series, including the original model (later retronymed "Model I"), Model II, Model III, and Model 4, which were equipped with a Z80 as their main processor, and some (but not all) other TRS-80 models which used the Z80 as either the main or a secondary processor. Another notable and unique machine is the DEC Rainbow 100, which featured both an Intel 8088 and a Z80 CPU, to support either the 8-bit CP/M-80 applications, running on the Z80, or CP/M-86 (or limited MS-DOS) applications running on the 8088.
In 1981, Multitech (later to become Acer) introduced the Microprofessor I, a simple and inexpensive training system for the Z80 microprocessor. Currently, it is still manufactured and sold by Flite Electronics International Limited in Southampton, England.
Portable and handheld computers.
Use of the Z80 in lighter, battery-operated devices became more widespread with the availability of CMOS versions of the processor. It also inspired the development of other CMOS based processors, such as the LH5801 from Sharp. The Sharp PC-1500, a BASIC-programmable pocket computer was released in 1981, followed by the improved Sharp PC-1600 in 1986 and the Sharp PC-E220 in 1991. Laptops which could run the CP/M operating system just like the desktop machines followed with Epson PX-8 Geneva in 1984, and in 1985 the Epson PX-4 and Bondwell-2. While the laptop market in subsequent years moved to more powerful Intel 8086 processors and the MS-DOS operating system, light-weight Z80-based systems with a longer battery life were still being introduced, such as the Cambridge Z88 in 1988 and the Amstrad NC100 in 1992. The Z80-derived Z8S180 also found its way into an early pen-operated personal digital assistant, the Amstrad PenPad PDA600 in 1993. Hong Kong-based VTech produced a line of small laptop computers called 'Lasers' based on a Z80. The last two were the Laser PC5 and PC6.
The Cidco MailStation Mivo 100, first released in 1999, was a stand-alone portable email device, with a Z80-based microcontroller.
Starting with the TI-81 in 1990, Texas Instruments has manufactured a long line of graphing calculators based on the Z80. The TI-84 Plus series, introduced in 2004, is still in production as of 2020. The TI-84 Plus CE series, introduced in 2015, uses the Z80-derived Zilog eZ80 processor and is also still in production as of 2020. TI also produced a line of pocket organizers (ended in 2000) using Toshiba processors built around a Z80 core; the first of these was the TI PS-6200 and after a lengthy production run of some dozen models culminated in their PocketMate series. Later models of the Sharp Wizard series of personal organizers were Z80 based.
Embedded systems and consumer electronics.
The Zilog Z80 has long been a popular microprocessor in embedded systems and microcontroller cores, where it remains in widespread use today. Applications of the Z80 include uses in consumer electronics, industrial products, and electronic musical instruments. For example, Z80 was used in the groundbreaking music synthesizer Prophet-5, as well as in the first MIDI synthesizer Prophet 600. Casio used the Z80A in its PV-1000 video game console.
A good number of early-1980s arcade video games, including the phenomenal hit Pac-Man, contain Z80 CPUs.
The Z80 was used in the Sega Master System and Sega Game Gear consoles. The Sega Genesis contains a Z80, with its own 8 KB of RAM, which runs in parallel with the MC68000 main CPU, has direct access to the system's sound chips and I/O (controller) ports, and has a switched data path to the main memory bus of the 68000 (providing access to the 64 KB main RAM, the software cartridge, and the whole video chip); in addition to providing backward compatibility with Master System games, the Z80 is often used to control audio in Genesis software.
Z80 CPUs were also used in the trailblazing and popular TI-8x series of graphing calculators from Texas Instruments, beginning in 1990 with the TI-81, which features a Z80 clocked at 2 MHz. Most higher-line calculators in the series, starting with the TI-82 and TI-85, clock their Z80 CPUs at 6 MHz or higher. A few models with TI-8x names use other CPUs, such as the M68000, but the vast majority are Z80-based. On those, it is possible to run assembled or compiled user programs in the form of Z80 machine-language code.
In the late 1980s, a series of Soviet landline phones called "AON" featured the Z80; these phones expanded the feature set of the landline with caller ID, different ringtones based on the caller, speed dial and so forth. In the second half of nineties manufacturers of these phones switched to 8051 compatible MCUs to reduce power consumption and prevent compact wall warts from overheating.

