
In number theory, integer factorization is the decomposition of a composite number into a product of smaller integers. If these factors are further restricted to prime numbers, the process is called prime factorization.
When the numbers are sufficiently large, no efficient, non-quantum integer factorization algorithm is known. In 2019, Fabrice Boudot, Pierrick Gaudry, Aurore Guillevic, Nadia Heninger, Emmanuel Thomé and Paul Zimmermann factored a 240-digit (795-bit) number (RSA-240) utilizing approximately 900 core-years of computing power. The researchers estimated that a 1024-bit RSA modulus would take about 500 times as long. However, it has not been proven that no efficient algorithm exists. The presumed difficulty of this problem is at the heart of widely used algorithms in cryptography such as RSA. Many areas of mathematics and computer science have been brought to bear on the problem, including elliptic curves, algebraic number theory, and quantum computing.
Not all numbers of a given length are equally hard to factor. The hardest instances of these problems (for currently known techniques) are semiprimes, the product of two prime numbers. When they are both large, for instance more than two thousand bits long, randomly chosen, and about the same size (but not too close, for example, to avoid efficient factorization by Fermat's factorization method), even the fastest prime factorization algorithms on the fastest computers can take enough time to make the search impractical; that is, as the number of digits of the primes being factored increases, the number of operations required to perform the factorization on any computer increases drastically.
Many cryptographic protocols are based on the difficulty of factoring large composite integers or a related problem—for example, the RSA problem. An algorithm that efficiently factors an arbitrary integer would render RSA-based public-key cryptography insecure.
Prime decomposition.
By the fundamental theorem of arithmetic, every positive integer has a unique prime factorization. (By convention, 1 is the empty product.) Testing whether the integer is prime can be done in polynomial time, for example, by the AKS primality test. If composite, however, the polynomial time tests give no insight into how to obtain the factors.
Given a general algorithm for integer factorization, any integer can be factored into its constituent prime factors by repeated application of this algorithm. The situation is more complicated with special-purpose factorization algorithms, whose benefits may not be realized as well or even at all with the factors produced during decomposition. For example, if where are very large primes, trial division will quickly produce the factors 3 and 19 but will take "p" divisions to find the next factor. As a contrasting example, if "n" is the product of the primes 13729, 1372933, and 18848997161, where , Fermat's factorization method will begin with which immediately yields and hence the factors and . While these are easily recognized as composite and prime respectively, Fermat's method will take much longer to factor the composite number because the starting value of for "a" is nowhere near 1372933.
Current state of the art.
Among the "b"-bit numbers, the most difficult to factor in practice using existing algorithms are those that are products of two primes of similar size. For this reason, these are the integers used in cryptographic applications. The largest such semiprime yet factored was RSA-250, a 829-bit number with 250 decimal digits, in February 2020. The total computation time was roughly 2700 core-years of computing using Intel Xeon Gold 6130 at 2.1 GHz. Like all recent factorization records, this factorization was completed with a highly optimized implementation of the general number field sieve run on hundreds of machines.
Difficulty and complexity.
No algorithm has been published that can factor all integers in polynomial time, that is, that can factor a "b"-bit number "n" in time O("b""k") for some constant "k". Neither the existence nor non-existence of such algorithms has been proved, but it is generally suspected that they do not exist and hence that the problem is not in class P. The problem is clearly in class NP, but it is generally suspected that it is not NP-complete, though this has not been proven.
There are published algorithms that are faster than O((1 + "ε")"b") for all positive "ε", that is, sub-exponential. As of 2021-03-12, the algorithm with best theoretical asymptotic running time is the general number field sieve (GNFS), first published in 1993, running on a "b"-bit number "n" in time.
For current computers, GNFS is the best published algorithm for large "n" (more than about 400 bits). For a quantum computer, however, Peter Shor discovered an algorithm in 1994 that solves it in polynomial time. This will have significant implications for cryptography if quantum computation becomes scalable. Shor's algorithm takes only time and O("b") space on "b"-bit number inputs. In 2001, Shor's algorithm was implemented for the first time, by using NMR techniques on molecules that provide 7 qubits.
It is not known exactly which complexity classes contain the decision version of the integer factorization problem (that is: does have a factor smaller than ?). It is known to be in both NP and co-NP, meaning that both "yes" and "no" answers can be verified in polynomial time. An answer of "yes" can be certified by exhibiting a factorization with . An answer of "no" can be certified by exhibiting the factorization of "n" into distinct primes, all larger than "k"; one can verify their primality using the AKS primality test, and then multiply them to obtain "n". The fundamental theorem of arithmetic guarantees that there is only one possible string of increasing primes that will be accepted, which shows that the problem is in both UP and co-UP. It is known to be in BQP because of Shor's algorithm.
The problem is suspected to be outside all three of the complexity classes P, NP-complete, and co-NP-complete. It is therefore a candidate for the NP-intermediate complexity class. If it could be proved to be either NP-complete or co-NP-complete, this would imply NP = co-NP, a very surprising result, and therefore integer factorization is widely suspected to be outside both these classes. Many people have tried to find classical polynomial-time algorithms for it and failed, and therefore it is widely suspected to be outside P.
In contrast, the decision problem "Is "n" a composite number?" (or equivalently: "Is "n" a prime number?") appears to be much easier than the problem of specifying factors of "n". The composite/prime problem can be solved in polynomial time (in the number "b" of digits of "n") with the AKS primality test. In addition, there are several probabilistic algorithms that can test primality very quickly in practice if one is willing to accept a vanishingly small possibility of error. The ease of primality testing is a crucial part of the RSA algorithm, as it is necessary to find large prime numbers to start with.
Factoring algorithms.
Special-purpose.
A special-purpose factoring algorithm's running time depends on the properties of the number to be factored or on one of its unknown factors: size, special form, etc. The parameters which determine the running time vary among algorithms.
An important subclass of special-purpose factoring algorithms is the "Category 1" or "First Category" algorithms, whose running time depends on the size of smallest prime factor. Given an integer of unknown form, these methods are usually applied before general-purpose methods to remove small factors. For example, naive trial division is a Category 1 algorithm.
General-purpose.
A general-purpose factoring algorithm, also known as a "Category 2", "Second Category", or "Kraitchik" "family" algorithm, has a running time which depends solely on the size of the integer to be factored. This is the type of algorithm used to factor RSA numbers. Most general-purpose factoring algorithms are based on the congruence of squares method.
Heuristic running time.
In number theory, there are many integer factoring algorithms that heuristically have expected running time
in little-o and L-notation.
Some examples of those algorithms are the elliptic curve method and the quadratic sieve.
Another such algorithm is the class group relations method proposed by Schnorr, Seysen, and Lenstra, which they proved only assuming the unproved Generalized Riemann Hypothesis (GRH).
Rigorous running time.
The Schnorr–Seysen–Lenstra probabilistic algorithm has been rigorously proven by Lenstra and Pomerance to have expected running time formula_3 by replacing the GRH assumption with the use of multipliers.
The algorithm uses the class group of positive binary quadratic forms of discriminant Δ denoted by "G"Δ.
"G"Δ is the set of triples of integers ("a", "b", "c") in which those integers are relative prime.
Schnorr–Seysen–Lenstra Algorithm.
Given an integer "n" that will be factored, where "n" is an odd positive integer greater than a certain constant. In this factoring algorithm the discriminant Δ is chosen as a multiple of "n", , where "d" is some positive multiplier. The algorithm expects that for one "d" there exist enough smooth forms in "G"Δ. Lenstra and Pomerance show that the choice of "d" can be restricted to a small set to guarantee the smoothness result.
Denote by "P"Δ the set of all primes "q" with Kronecker symbol formula_4. By constructing a set of generators of "G"Δ and prime forms "f"q of "G"Δ with "q" in "P"Δ a sequence of relations between the set of generators and "f"q are produced.
The size of "q" can be bounded by formula_5 for some constant formula_6.
The relation that will be used is a relation between the product of powers that is equal to the neutral element of "G"Δ. These relations will be used to construct a so-called ambiguous form of "G"Δ, which is an element of "G"Δ of order dividing 2. By calculating the corresponding factorization of Δ and by taking a gcd, this ambiguous form provides the complete prime factorization of "n". This algorithm has these main steps:
Let "n" be the number to be factored.
To obtain an algorithm for factoring any positive integer, it is necessary to add a few steps to this algorithm such as trial division, and the Jacobi sum test.
Expected running time.
The algorithm as stated is a probabilistic algorithm as it makes random choices. Its expected running time is at most formula_3.

